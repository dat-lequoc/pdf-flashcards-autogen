<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document Viewer with Flashcard Generation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.9.359/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js"></script>
    <link rel="stylesheet" href="/static/css/styles.css">
</head>

<body>
    <div id="top-bar">
        <input type="file" id="file-input" accept=".pdf,.txt,.epub">
        <span id="current-page">Page: 1</span>
    </div>
    <div id="left-panel">
        <div id="pdf-viewer"></div>
        <div id="epub-viewer"></div>
        <div id="epub-controls" style="display: none;">
            <button id="prev-btn">Previous</button>
            <button id="next-btn">Next</button>
            <span id="current-location"></span>
        </div>
    </div>
    <div id="right-panel">
        <div id="right-panel-content">
            <div id="top-controls">
                <div id="settings-icon">⚙️</div>
                <div id="page-navigation">
                    <button id="zoom-out-btn">-</button>
                    <button id="zoom-in-btn">+</button>
                    <input type="number" id="page-input" min="1" placeholder="Go to page">
                    <button id="go-to-page-btn">Go</button>
                </div>
            </div>
            <div id="settings-panel" style="display: none;">
                <input type="password" id="api-key-input" placeholder="Enter Claude API Key">
                <select id="model-select">
                    <option value="claude-3-5-sonnet-20240620">Claude 3.5 Sonnet</option>
                    <option value="claude-3-haiku-20240307">Claude 3 Haiku</option>
                </select>
                <textarea id="system-prompt" placeholder="Enter system prompt for flashcard generation">
                    You will be given a text passage to analyze and create flashcards from. Your task is to generate concise, informative, knowledgeable flashcards based on the key concepts and information presented in the text.

Here is the text:

<text>
<TEXT>
</text>

Follow these guidelines to create effective flashcards:

1. Carefully analyze the text and identify the most important concepts, facts, and ideas.
2. Craft clear, concise questions that test these essential concepts.
3. Provide brief but complete answers. Use bullet points when appropriate.
4. Ensure each flashcard is self-contained. Include relevant examples or code snippets in the question if necessary for understanding or answering.
5. Use <b> tags to highlight important words or phrases in both the question and the answer.
6. Answer directly without repeating the question in the answer.

Format your flashcards as follows:
<Q> [Question] </Q>
<A> [Answer] </A>
[... additional flashcards as needed ...]

Create between 1 and 10 flashcards, as many high-quality flashcards as the content allows.

Now, proceed with creating the flashcards based on the provided text. Remember to use the specified format and follow the guidelines closely.</textarea>

                <textarea id="explain-prompt" placeholder="Enter system prompt for explanation" style="display: none;">Explain the following text in simple terms: 

<text>
<TEXT>
</text>

Focusing on the main concepts. Use clear and concise language, and break down complex ideas into easily understandable parts. If there are any technical terms, provide brief explanations for them. 

Now, provide your answer in markdown format based on the provided text.</textarea>

                <textarea id="language-prompt" placeholder="Enter system prompt for language mode">You are an AI language assistant tasked with providing information about a given word in multiple languages. Your goal is to provide a translation, an example, and an explanation for the given word based on the provided inputs.

Here are the inputs you will be working with:

Word: <word><WORD></word>
Phrase: <phrase><PHRASE></phrase>

Present your output in the following format:
<T>[Translation of the word in <TRANSLATION_LANGUAGE>]</T>
<Q>[An example sentence in <TARGET_LANGUAGE> that contains the exact form of the word. The word must be enclosed in <b></b> tags]</Q>
<A>[Short explanation of the word's meaning in <TARGET_LANGUAGE>]</A>

Here's an example of the expected output:
Word: "escalated"
Phrase: "etween the two countries after the border"
<T>leo thang</T>
<Q>Tensions <b>escalated</b> between the two countries after the border incident.</Q>
<A>Increased rapidly in intensity or severity.</A>

Additional guidelines:
- The example sentence must contain the exact form of the word as provided in the input, in the correct language, as shown the example.
- If you are unsure about any part of the task, still give the best response you can in the given format, based on the information available.
- Do not include any additional commentary or explanations outside of the specified output format.
- Remember to use <b> tags for the word in the example.

Remember to focus solely on the given word and the required outputs. Now, proceed with the task using the provided inputs and following the instructions given above.</textarea>
            </div>
            <div id="mode-toggle">
                <button class="mode-btn selected" data-mode="flashcard">Flashcard</button>
                <button class="mode-btn" data-mode="explain">Explain</button>
                <button class="mode-btn" data-mode="language">Language</button>
            </div>
            <div id="language-buttons" style="display: none; margin-top: 10px;">
                <button class="mode-btn" data-language="English">English</button>
                <button class="mode-btn" data-language="French">French</button>
            </div>
            <button id="submit-btn" style="display: block;">Generate</button>
            <div id="flashcards"></div>
            <div id="collection">
                <button id="add-to-collection-btn">Add to Collection (0)</button>
                <button id="clear-collection-btn">Clear Collection</button>
            </div>
            <button id="export-csv-btn" style="display: none;">Export Flashcards to CSV</button>
            <div id="recent-files">
                <h3>Recent Files</h3>
                <ul id="file-list"></ul>
            </div>
            <div id="highlight-instruction"
                style="font-size: 0.7em; color: #666; margin-bottom: 25px;">Use Alt+Select to highlight text</div>
        </div>
        <div id="progress-bar-container" style="height: 20px; background-color: #f0f0f0;">
            <div id="progress-bar" style="width: 0%; height: 100%; background-color: #4CAF50;"></div>
            <div id="progress-text" style="position: absolute; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; font-size: 12px;"></div>
        </div>
    </div>

    <!-- Explanation Modal -->
    <div id="explanationModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <div id="explanationModalContent"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/showdown/1.9.1/showdown.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.9.359/pdf.worker.min.js';

        const fileInput = document.getElementById('file-input');
        const pdfViewer = document.getElementById('pdf-viewer');
        const modeToggle = document.getElementById('mode-toggle');
        const systemPrompt = document.getElementById('system-prompt');
        const submitBtn = document.getElementById('submit-btn');
        const flashcardsContainer = document.getElementById('flashcards');
        const apiKeyInput = document.getElementById('api-key-input');
        const modelSelect = document.getElementById('model-select');
        const recentPdfList = document.getElementById('recent-pdf-list');

        let pdfDoc = null;
        let pageNum = 1;
        let pageRendering = false;
        let pageNumPending = null;
        let scale = 3;
        const minScale = 0.5;
        const maxScale = 5;
        let mode = 'flashcard';
        let apiKey = '';
        let currentFileName = '';
        let currentPage = 1;
        let selectedModel = 'claude-3-haiku-20240307';
        let lastProcessedQuery = '';
        let lastRequestTime = 0;
        const cooldownTime = 1000; // 1 second cooldown

        function renderPage(num) {
            pageRendering = true;
            pdfDoc.getPage(num).then(function (page) {
                const viewport = page.getViewport({ scale: scale });
                const pixelRatio = window.devicePixelRatio || 1;
                const adjustedViewport = page.getViewport({ scale: scale * pixelRatio });

                const pageDiv = document.createElement('div');
                pageDiv.className = 'page';
                pageDiv.dataset.pageNumber = num;
                pageDiv.style.width = `${viewport.width}px`;
                pageDiv.style.height = `${viewport.height}px`;

                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.height = adjustedViewport.height;
                canvas.width = adjustedViewport.width;
                canvas.style.width = `${viewport.width}px`;
                canvas.style.height = `${viewport.height}px`;

                const renderContext = {
                    canvasContext: ctx,
                    viewport: adjustedViewport,
                    enableWebGL: true,
                    renderInteractiveForms: true,
                };

                const renderTask = page.render(renderContext);

                renderTask.promise.then(function () {
                    pageRendering = false;
                    if (pageNumPending !== null) {
                        renderPage(pageNumPending);
                        pageNumPending = null;
                    }
                });

                pageDiv.appendChild(canvas);

                // Text layer
                const textLayerDiv = document.createElement('div');
                textLayerDiv.className = 'text-layer';
                textLayerDiv.style.width = `${viewport.width}px`;
                textLayerDiv.style.height = `${viewport.height}px`;
                pageDiv.appendChild(textLayerDiv);

                page.getTextContent().then(function (textContent) {
                    pdfjsLib.renderTextLayer({
                        textContent: textContent,
                        container: textLayerDiv,
                        viewport: viewport,
                        textDivs: []
                    });
                });

                pdfViewer.appendChild(pageDiv);

                attachLanguageModeListener(pageDiv);
                renderHighlights();
                if (num < pdfDoc.numPages && pdfViewer.scrollHeight <= window.innerHeight * 2) {
                    renderPage(num + 1);
                }
            }).catch(function (error) {
                console.error('Error rendering page:', error);
            });
        }

        function loadPDF(file) {
            const fileReader = new FileReader();
            fileReader.onload = function () {
                const typedarray = new Uint8Array(this.result);

                pdfjsLib.getDocument(typedarray).promise.then(function (pdf) {
                    pdfDoc = pdf;
                    pdfViewer.innerHTML = '';
                    currentFileName = file.name;
                    const lastPage = localStorage.getItem(`lastPage_${currentFileName}`);
                    pageNum = lastPage ? Math.max(parseInt(lastPage) - 2, 1) : 1;
                    loadScaleForCurrentFile();
                    renderPage(pageNum);
                    updateCurrentPage(pageNum);
                    hideHeaderPanel();
                    loadHighlights();
                    updateProgressBar(pageNum);
                });
            };
            fileReader.readAsArrayBuffer(file);
        }

        function loadTXT(file) {
            const fileReader = new FileReader();
            fileReader.onload = function () {
                const content = this.result;
                pdfViewer.innerHTML = '';
                currentFileName = file.name;
                const textContainer = document.createElement('div');
                textContainer.className = 'text-content';
                textContainer.textContent = content;
                pdfViewer.appendChild(textContainer);
                hideHeaderPanel();
                attachLanguageModeListener(textContainer);
            };
            fileReader.readAsText(file);
        }

        function hideHeaderPanel() {
            document.getElementById('top-bar').style.display = 'none';
        }

        function goToPage(num) {
            if (num >= 1 && num <= pdfDoc.numPages) {
                pageNum = num;
                pdfViewer.innerHTML = '';
                renderPage(pageNum);
                updateCurrentPage(pageNum);
                localStorage.setItem(`lastPage_${currentFileName}`, pageNum);
            } else {
                alert('Invalid page number');
            }
        }

        function updateCurrentPage(num) {
            if (num !== currentPage) {
                currentPage = num;
                document.getElementById('current-page').textContent = `Page: ${num}`;
                document.getElementById('page-input').value = num;
                localStorage.setItem(`lastPage_${currentFileName}`, num);
                updateProgressBar(num);
            }
        }

        function updateProgressBar(currentPage) {
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');
            let totalPages = 1;
            if (pdfDoc) {
                totalPages = pdfDoc.numPages;
            } else if (book && book.packaging && book.packaging.metadata) {
                totalPages = book.packaging.metadata.numberOfPages;
            }
            const progress = (currentPage / totalPages) * 100;
            progressBar.style.width = `${progress}%`;
            progressText.textContent = `${currentPage} / ${totalPages}`;
            
            // Save progress to localStorage
            if (currentFileName) {
                const roundedProgress = Math.round(progress);
                localStorage.setItem(`progress_${currentFileName}`, roundedProgress);
            }
        }

        // Infinite scrolling with page tracking
        document.getElementById('left-panel').addEventListener('scroll', function () {
            if (this.scrollTop + this.clientHeight >= this.scrollHeight - 500) {
                if (pageNum < pdfDoc.numPages) {
                    pageNum++;
                    renderPage(pageNum);
                }
            }

            // Update current page based on scroll position
            const pages = document.querySelectorAll('.page');
            for (let i = 0; i < pages.length; i++) {
                const page = pages[i];
                const rect = page.getBoundingClientRect();
                if (rect.top >= 0 && rect.bottom <= window.innerHeight) {
                    const newPageNum = parseInt(page.dataset.pageNumber);
                    updateCurrentPage(newPageNum);
                    break;
                }
            }
        });

        function handleLanguageMode(event, targetLanguage) {
            if (mode !== 'language') return;

            event.preventDefault();
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                const selectedText = selection.toString().trim();
                if (selectedText) {
                    const phrase = getPhrase(range);
                    const currentTime = Date.now();
                    if (phrase !== lastProcessedQuery && currentTime - lastRequestTime >= cooldownTime) {
                        lastProcessedQuery = phrase;
                        lastRequestTime = currentTime;
                        speakWord(selectedText);
                        generateLanguageFlashcard(selectedText, phrase, targetLanguage);
                    }

                }
            }
        }

        let voices = [];

        function populateVoiceList() {
            voices = speechSynthesis.getVoices();
        }

        populateVoiceList();
        if (speechSynthesis.onvoiceschanged !== undefined) {
            speechSynthesis.onvoiceschanged = populateVoiceList;
        }

        function speakWord(word) {
            console.log('Attempting to speak word:', word);

            const utterance = new SpeechSynthesisUtterance(word);
            utterance.rate = 0.8; // Slightly slower rate for clarity

            let englishVoice;
            if (voices.length > 1) {
                englishVoice = voices[2];
                console.log('Using second voice in the list:', englishVoice.name);
            } else {
                englishVoice = voices.find(voice => voice.name === "Microsoft Zira Desktop - English (United States)") ||
                    voices.find(voice => /en/i.test(voice.lang));
                if (englishVoice) {
                    console.log('Using voice:', englishVoice.name);
                } else {
                    console.log('No suitable English voice found. Using default voice.');
                }
            }

            if (englishVoice) {
                utterance.voice = englishVoice;
            }

            try {
                speechSynthesis.speak(utterance);
            } catch (error) {
                console.error('Error initiating speech:', error);
            }
        }

        function getPhrase(range) {
            const sentenceStart = /[.!?]\s+[A-Z]|^[A-Z]/;
            const sentenceEnd = /[.!?](?=\s|$)/;

            let startNode = range.startContainer;
            let endNode = range.endContainer;
            let startOffset = range.startOffset;
            let endOffset = range.endOffset;

            // Expand to sentence boundaries
            while (startNode && startNode.textContent && !sentenceStart.test(startNode.textContent.slice(0, startOffset))) {
                if (startNode.previousSibling) {
                    startNode = startNode.previousSibling;
                    startOffset = startNode.textContent ? startNode.textContent.length : 0;
                } else if (startNode.parentNode && startNode.parentNode.previousSibling) {
                    startNode = startNode.parentNode.previousSibling.lastChild;
                    startOffset = startNode && startNode.textContent ? startNode.textContent.length : 0;
                } else {
                    break;
                }
            }

            while (endNode && endNode.textContent && !sentenceEnd.test(endNode.textContent.slice(endOffset))) {
                if (endNode.nextSibling) {
                    endNode = endNode.nextSibling;
                    endOffset = 0;
                } else if (endNode.parentNode && endNode.parentNode.nextSibling) {
                    endNode = endNode.parentNode.nextSibling.firstChild;
                    endOffset = 0;
                } else {
                    break;
                }
            }

            // Check if we have valid start and end nodes
            if (startNode && startNode.nodeType === Node.TEXT_NODE &&
                endNode && endNode.nodeType === Node.TEXT_NODE &&
                startNode.textContent && endNode.textContent) {
                const phraseRange = document.createRange();
                phraseRange.setStart(startNode, startOffset);
                phraseRange.setEnd(endNode, endOffset);
                return phraseRange.toString().trim();
            } else {
                // If we don't have valid nodes, return the original selection
                return range.toString().trim();
            }
        }

        function getFullSentence(text, word) {
            const sentenceRegex = /[^.!?]+[.!?]+\s*/g;
            const sentences = text.match(sentenceRegex) || [text];

            const matchingSentences = sentences.filter(sentence =>
                new RegExp(`\\b${word}\\b`, 'i').test(sentence)
            );

            if (matchingSentences.length === 0) {
                const wordIndex = text.indexOf(word);
                if (wordIndex !== -1) {
                    const start = Math.max(0, wordIndex - 30);
                    const end = Math.min(text.length, wordIndex + word.length + 30);
                    return text.slice(start, end);
                }
                return text;
            } else if (matchingSentences.length === 1) {
                // If only one matching sentence, return it
                return matchingSentences[0].trim();
            } else {
                // If multiple matching sentences, return them joined
                return matchingSentences.join(' ').trim();
            }
        }

        async function generateLanguageFlashcard(word, phrase, targetLanguage) {
            if (!apiKey) {
                alert('Please enter your Claude API key first.');
                return;
            }

            console.log("Translate: ", word, phrase);
            console.log(document.getElementById('language-prompt').value);
            const prompt = document.getElementById('language-prompt').value
                .replace(/<WORD>/g, word)
                .replace(/<PHRASE>/g, phrase)
                .replace(/<TRANSLATION_LANGUAGE>/g, 'Vietnamese')
                .replace(/<TARGET_LANGUAGE>/g, targetLanguage);

            console.log("Prompt", prompt);

            try {
                const response = await callClaudeAPI(prompt);
                if (response.flashcard) {
                    const flashcard = response.flashcard;
                    const formattedFlashcard = {
                        question: flashcard.question,
                        answer: flashcard.answer,
                        word: flashcard.word,
                        translation: flashcard.translation
                    };
                    console.log(formattedFlashcard);
                    displayLanguageFlashcard(formattedFlashcard);
                } else {
                    throw new Error('Invalid response from API');
                }
            } catch (error) {
                console.error('Error calling Claude API:', error);
                alert('Failed to generate language flashcard. Please check your API key and try again.');
            }
        }

        async function generateContent() {
            if (!apiKey) {
                alert('Please enter your Claude API key first.');
                return;
            }

            const selection = window.getSelection();
            if (selection.rangeCount > 0 && selection.toString().trim() !== '') {
                const selectedText = selection.toString();
                let prompt;

                if (mode === 'flashcard') {
                    prompt = systemPrompt.value.replace('<TEXT>', selectedText);
                } else if (mode === 'explain') {
                    const explainPromptValue = document.getElementById('explain-prompt').value;
                    prompt = explainPromptValue.replace('<TEXT>', selectedText);
                } else {
                    return;
                }

                // Disable the button, change its color, and show notification
                submitBtn.disabled = true;
                submitBtn.style.backgroundColor = '#808080'; // Change to gray
                const notification = document.createElement('div');
                notification.textContent = 'Generating...';
                notification.style.position = 'fixed';
                notification.style.top = '20px';
                notification.style.right = '20px';
                notification.style.padding = '10px';
                notification.style.backgroundColor = 'rgba(0, 128, 0, 0.7)'; // Change to green
                notification.style.color = 'white';
                notification.style.borderRadius = '5px';
                notification.style.zIndex = '1000';
                document.body.appendChild(notification);

                try {
                    const response = await callClaudeAPI(prompt);
                    if (mode === 'flashcard' && response.flashcards) {
                        displayFlashcards(response.flashcards, true);
                    } else if (mode === 'explain' && response.explanation) {
                        displayExplanation(response.explanation);
                    } else {
                        throw new Error('Invalid response from API');
                    }
                } catch (error) {
                    console.error('Error calling Claude API:', error);
                    alert(`Failed to generate ${mode === 'flashcard' ? 'flashcards' : 'explanation'}. Please check your API key and try again.`);
                } finally {
                    // Remove notification, re-enable button, and restore its color after 3 seconds
                    setTimeout(() => {
                        document.body.removeChild(notification);
                        submitBtn.disabled = false;
                        submitBtn.style.backgroundColor = ''; // Restore original color
                    }, 3000);
                }
            } else {
                alert(`Please select some text from the PDF to generate ${mode === 'flashcard' ? 'flashcards' : 'an explanation'}.`);
            }
        }

        function displayExplanation(explanation) {
            // Display in right panel
            const explanationElement = document.createElement('div');
            explanationElement.className = 'explanation';
            explanationElement.innerHTML = `
                <h3>Explanation</h3>
                <div class="explanation-content">${explanation}</div>
                <button class="remove-btn">Remove</button>
            `;
            explanationElement.querySelector('.remove-btn').addEventListener('click', function () {
                explanationElement.remove();
            });
            flashcardsContainer.appendChild(explanationElement);

            // Display in modal
            const modal = document.getElementById('explanationModal');
            const modalContent = document.getElementById('explanationModalContent');
            const closeBtn = document.getElementsByClassName('close')[0];

            // Convert markdown to HTML
            const converter = new showdown.Converter();
            const htmlContent = converter.makeHtml(explanation);

            modalContent.innerHTML = htmlContent;
            modal.style.display = 'block';

            closeBtn.onclick = function () {
                modal.style.display = 'none';
            }

            window.onclick = function (event) {
                if (event.target == modal) {
                    modal.style.display = 'none';
                }
            }
        }

        async function callClaudeAPI(prompt) {
            const response = await fetch('/generate_flashcard', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-API-Key': apiKey
                },
                body: JSON.stringify({
                    prompt: prompt,
                    model: selectedModel,
                    mode: mode // Add the current mode to the request
                })
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            return await response.json();
        }

        modelSelect.addEventListener('change', function () {
            selectedModel = this.value;
        });

        function displayFlashcards(flashcards, append = false) {
            if (!append) {
                flashcardsContainer.innerHTML = ''; // Clear existing flashcards only if not appending
            }
            flashcards.forEach(flashcard => {
                const flashcardElement = document.createElement('div');
                flashcardElement.className = 'flashcard';
                flashcardElement.innerHTML = `
                    <strong>Q:</strong> ${flashcard.question}<br>
                    <strong>A:</strong> ${flashcard.answer.trim().replace(/\n/g, '<br>')}
                    <button class="remove-btn">Remove</button>
                `;
                flashcardElement.querySelector('.remove-btn').addEventListener('click', function () {
                    flashcardElement.remove();
                    updateExportButtonVisibility();
                });
                flashcardsContainer.insertBefore(flashcardElement, flashcardsContainer.firstChild);
            });
            updateExportButtonVisibility();
        }

        function displayLanguageFlashcard(flashcard) {
            const flashcardElement = document.createElement('div');
            flashcardElement.className = 'flashcard language-flashcard';
            flashcardElement.dataset.question = flashcard.question;
            flashcardElement.dataset.word = flashcard.word;
            flashcardElement.dataset.translation = flashcard.translation;
            flashcardElement.dataset.answer = flashcard.answer;
            flashcardElement.innerHTML = `
                <div style="font-size: 1.2em; margin-bottom: 10px;"><b>${flashcard.word}</b>: ${flashcard.translation}</div>
                <div>- ${flashcard.answer}</div>
                <button class="remove-btn">Remove</button>
            `;
            flashcardElement.querySelector('.remove-btn').addEventListener('click', function () {
                flashcardElement.remove();
                updateExportButtonVisibility();
            });
            flashcardsContainer.insertBefore(flashcardElement, flashcardsContainer.firstChild);
            updateExportButtonVisibility();
        }

        let flashcardCollectionCount = 0;
        let languageCollectionCount = 0;
        let collectedFlashcards = [];
        let collectedLanguageFlashcards = [];

        function addToCollection() {
            const newFlashcards = Array.from(document.querySelectorAll('.flashcard:not(.in-collection)')).map(flashcard => {
                if (flashcard.classList.contains('language-flashcard')) {
                    const word = flashcard.dataset.word;
                    const translation = flashcard.dataset.translation;
                    const answer = flashcard.dataset.answer;
                    const question = flashcard.dataset.question;
                    return {
                        word: word,
                        phrase: question,
                        translationAnswer: `${translation.trim()}\n${answer.trim()}`
                    };
                } else {
                    const question = flashcard.querySelector('strong').nextSibling.textContent.trim();
                    const answer = flashcard.innerHTML.split('<br>')[1].split('<button')[0].trim();
                    return {
                        phrase: question,
                        translationAnswer: answer
                    };
                }
            });

            if (mode === 'language') {
                collectedLanguageFlashcards = collectedLanguageFlashcards.concat(newFlashcards);
                updateCollectionCount(newFlashcards.length, 'language');
            } else {
                collectedFlashcards = collectedFlashcards.concat(newFlashcards);
                updateCollectionCount(newFlashcards.length, 'flashcard');
            }
            clearDisplayedFlashcards();
            updateExportButtonVisibility();
        }

        function clearDisplayedFlashcards() {
            flashcardsContainer.innerHTML = '';
        }

        function updateCollectionCount(change, collectionType) {
            if (collectionType === 'language') {
                languageCollectionCount += change;
                localStorage.setItem('languageCollectionCount', languageCollectionCount);
                localStorage.setItem('collectedLanguageFlashcards', JSON.stringify(collectedLanguageFlashcards));
            } else {
                flashcardCollectionCount += change;
                localStorage.setItem('flashcardCollectionCount', flashcardCollectionCount);
                localStorage.setItem('collectedFlashcards', JSON.stringify(collectedFlashcards));
            }
            updateAddToCollectionButtonText();
        }

        function updateAddToCollectionButtonText() {
            const addToCollectionBtn = document.getElementById('add-to-collection-btn');
            const count = mode === 'language' ? languageCollectionCount : flashcardCollectionCount;
            addToCollectionBtn.textContent = `Add to Collection (${count})`;
        }

        // Initialize collection counts and flashcards from localStorage
        flashcardCollectionCount = parseInt(localStorage.getItem('flashcardCollectionCount')) || 0;
        languageCollectionCount = parseInt(localStorage.getItem('languageCollectionCount')) || 0;
        collectedFlashcards = JSON.parse(localStorage.getItem('collectedFlashcards')) || [];
        collectedLanguageFlashcards = JSON.parse(localStorage.getItem('collectedLanguageFlashcards')) || [];
        updateAddToCollectionButtonText();

        document.getElementById('add-to-collection-btn').addEventListener('click', addToCollection);

        function updateExportButtonVisibility() {
            const exportButton = document.getElementById('export-csv-btn');
            const currentCollection = mode === 'language' ? collectedLanguageFlashcards : collectedFlashcards;
            exportButton.style.display = currentCollection.length > 0 ? 'block' : 'none';
        }

        function exportToCSV() {
            let csvContent = "data:text/csv;charset=utf-8,";
            const currentCollection = mode === 'language' ? collectedLanguageFlashcards : collectedFlashcards;
            const removeQuotes = str => str.replace(/"/g, '""');
            const replaceNewlines = str => str.replace(/\n/g, '<br>');

            if (mode === 'language') {
                currentCollection.forEach(({ phrase, translationAnswer }) => {
                    const [translation, answer] = translationAnswer.split('\n');
                    csvContent += `"${removeQuotes(phrase)}";"-${removeQuotes(replaceNewlines(translation))}<br>- ${removeQuotes(replaceNewlines(answer))}"\n`;
                });
            } else {
                currentCollection.forEach(({ phrase, translationAnswer }) => {
                    console.log(translationAnswer);
                    csvContent += `"${removeQuotes(phrase)}";"${removeQuotes(replaceNewlines(translationAnswer))}"\n`;
                });
            }

            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", `${mode}_flashcards.csv`);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        document.getElementById('export-csv-btn').addEventListener('click', exportToCSV);

        function clearCollection() {
            if (confirm('Are you sure you want to clear the entire collection? This action cannot be undone.')) {
                if (mode === 'language') {
                    collectedLanguageFlashcards = [];
                    languageCollectionCount = 0;
                    localStorage.removeItem('collectedLanguageFlashcards');
                    localStorage.removeItem('languageCollectionCount');
                } else {
                    collectedFlashcards = [];
                    flashcardCollectionCount = 0;
                    localStorage.removeItem('collectedFlashcards');
                    localStorage.removeItem('flashcardCollectionCount');
                }
                updateCollectionCount(0, mode);
                updateExportButtonVisibility();
            }
        }

        document.getElementById('clear-collection-btn').addEventListener('click', clearCollection);

        // Initialize export button visibility
        updateExportButtonVisibility();

        function addRecentFile(filename) {
            let recentFiles = JSON.parse(localStorage.getItem('recentFiles')) || [];
            recentFiles = recentFiles.filter(file => file.filename !== filename);
            recentFiles.unshift({ filename: filename, date: new Date().toISOString() });
            recentFiles = recentFiles.slice(0, 10);  // Keep only the 10 most recent
            localStorage.setItem('recentFiles', JSON.stringify(recentFiles));
            loadRecentFiles();
        }

        function updateRecentPDFsList() {
            const recentPDFs = JSON.parse(localStorage.getItem('recentPDFs')) || [];
            recentPdfList.innerHTML = '';
            recentPDFs.forEach(pdf => {
                const li = document.createElement('li');
                li.textContent = `${pdf.filename} (${new Date(pdf.date).toLocaleDateString()})`;
                recentPdfList.appendChild(li);
            });
        }

        fileInput.addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (file.type !== 'application/pdf' && file.type !== 'text/plain' && file.type !== 'application/epub+zip') {
                console.error('Error: Not a PDF, TXT, or EPUB file');
                return;
            }
            loadFile(file);
            addRecentFile(file.name);
            this.nextElementSibling.textContent = file.name;
        });

        // Add a span next to the file input to display the selected file name
        const fileNameDisplay = document.createElement('span');
        fileNameDisplay.style.marginLeft = '10px';
        fileInput.parentNode.insertBefore(fileNameDisplay, fileInput.nextSibling);

        function handleGoToPage() {
            const pageInput = document.getElementById('page-input');
            const pageNumber = parseInt(pageInput.value);
            goToPage(pageNumber);
        }

        document.getElementById('go-to-page-btn').addEventListener('click', handleGoToPage);

        document.getElementById('page-input').addEventListener('keyup', function (event) {
            if (event.key === 'Enter') {
                handleGoToPage();
            }
        });

        function calculateZoomStep(currentScale) {
            return Math.max(0.1, Math.min(0.25, currentScale * 0.1));
        }

        document.getElementById('zoom-in-btn').addEventListener('click', function () {
            if (scale < maxScale) {
                const step = calculateZoomStep(scale);
                scale = Math.min(maxScale, scale + step);
                reRenderPDF();
                saveScaleForCurrentFile();
            }
        });

        document.getElementById('zoom-out-btn').addEventListener('click', function () {
            if (scale > minScale) {
                const step = calculateZoomStep(scale);
                scale = Math.max(minScale, scale - step);
                reRenderPDF();
                saveScaleForCurrentFile();
            }
        });

        function reRenderPDF() {
            pdfViewer.innerHTML = '';
            renderPage(pageNum);
        }

        function saveScaleForCurrentFile() {
            if (currentFileName) {
                localStorage.setItem(`scale_${currentFileName}`, scale);
            }
        }

        function loadScaleForCurrentFile() {
            if (currentFileName) {
                const savedScale = localStorage.getItem(`scale_${currentFileName}`);
                if (savedScale) {
                    scale = parseFloat(savedScale);
                }
            }
        }

        const modeButtons = document.querySelectorAll('.mode-btn');
        modeButtons.forEach(button => {
            button.addEventListener('click', function () {
                modeButtons.forEach(btn => btn.classList.remove('selected'));
                this.classList.add('selected');
                mode = this.dataset.mode;
                pdfViewer.style.cursor = mode === 'language' ? 'text' : 'default';
                document.getElementById('language-buttons').style.display = mode === 'language' ? 'flex' : 'none';
                systemPrompt.style.display = mode === 'flashcard' ? 'block' : 'none';
                document.getElementById('explain-prompt').style.display = mode === 'explain' ? 'block' : 'none';
                document.getElementById('language-prompt').style.display = mode === 'language' ? 'block' : 'none';
                submitBtn.style.display = mode === 'language' ? 'none' : 'block';
                submitBtn.textContent = mode === 'flashcard' ? 'Generate Flashcards' : 'Generate Explanation';

                if (mode === 'language') {
                    const savedLanguage = loadLanguageChoice();
                    setLanguageButton(savedLanguage);
                }

                // Update Add to Collection button and export button visibility
                updateAddToCollectionButtonText();
                updateExportButtonVisibility();
            });
        });

        const languageButtons = document.querySelectorAll('#language-buttons .mode-btn');
        languageButtons.forEach(button => {
            button.addEventListener('click', function (event) {
                event.preventDefault();
                languageButtons.forEach(btn => btn.classList.remove('selected'));
                this.classList.add('selected');
                const targetLanguage = this.dataset.language;
                saveLanguageChoice(targetLanguage);
                // Ensure the Language mode button remains selected
                document.querySelector('.mode-btn[data-mode="language"]').classList.add('selected');
                // Keep language buttons visible and Generate button hidden
                document.getElementById('language-buttons').style.display = 'flex';
                submitBtn.style.display = 'none';
                // Set the mode to 'language'
                mode = 'language';
            });
        });

        let highlights = [];

        function attachLanguageModeListener(container) {
            container.addEventListener('mouseup', function (event) {
                if (event.altKey) {
                    const selection = window.getSelection();
                    if (selection.rangeCount > 0) {
                        const selectedText = selection.toString().trim();
                        if (selectedText !== '') {
                            translateText(selectedText);
                         }

                        const range = selection.getRangeAt(0);
                        const span = document.createElement('span');
                        span.className = 'highlight';
                        range.surroundContents(span);
                     }

                }
            });

            container.addEventListener('dblclick', function (event) {
                if (mode === 'language') {
                    const selection = window.getSelection();
                    const range = selection.getRangeAt(0);
                    const word = selection.toString().trim();

                    if (word !== '' && word.length < 20) {
                        // Highlight the selected word
                        const span = document.createElement('span');
                        span.style.backgroundColor = 'rgba(255, 255, 0, 0.5)';
                        span.textContent = word;
                        range.deleteContents();
                        range.insertNode(span);

                        const selectedLanguageButton = document.querySelector('#language-buttons .mode-btn.selected');
                        if (selectedLanguageButton) {
                            const targetLanguage = selectedLanguageButton.dataset.language;
                            const phrase = getPhrase(range, word);
                            generateLanguageFlashcard(word, phrase, targetLanguage);
                            speakWord(word);
                        } else {
                            console.error('No language selected');
                        }
                    }
                }
            });
        }

        async function translateText(text) {
            if (!apiKey) {
                alert('Please enter your Claude API key first.');
                return;
            }

            const prompt = `Translate the text below to Vietnamese with no further explanation:\nText: ${text}\nTranslation: `;

            try {
                const response = await callClaudeAPI(prompt);
                response.text = text
                displayTranslationFlashcard(response);
            } catch (error) {
                console.error('Error calling Claude API:', error);
                alert('Failed to translate text. Please check your API key and try again.');
            }
        }

        function displayTranslationFlashcard(response) {
            const flashcardElement = document.createElement('div');
            flashcardElement.className = 'flashcard translation-flashcard';
            flashcardElement.innerHTML = `
            <div style="font-size: 1.2em; margin-bottom: 10px;"><b>${response.translation}</b><br>
                       <span style="font-size: 0.7em;">${response.text}</span>
           </div>
                <button class="remove-btn">Remove</button>
            `;
            flashcardElement.querySelector('.remove-btn').addEventListener('click', function () {
                flashcardElement.remove();
                updateExportButtonVisibility();
             });
            flashcardsContainer.insertBefore(flashcardElement, flashcardsContainer.firstChild);
            updateExportButtonVisibility();
         }

        function createHighlight(range, pageDiv) {
            const highlight = document.createElement('div');
            highlight.className = 'highlight';
            highlight.style.position = 'absolute';
            highlight.style.backgroundColor = 'rgba(255, 255, 0, 0.3)';
            highlight.style.pointerEvents = 'none';

            const rect = range.getBoundingClientRect();
            const pageBounds = pageDiv.getBoundingClientRect();

            highlight.style.left = (rect.left - pageBounds.left) + 'px';
            highlight.style.top = (rect.top - pageBounds.top) + 'px';
            highlight.style.width = rect.width + 'px';
            highlight.style.height = rect.height + 'px';

            pageDiv.appendChild(highlight);

            return {
                element: highlight,
                pageNumber: parseInt(pageDiv.dataset.pageNumber),
                rect: {
                    left: rect.left - pageBounds.left,
                    top: rect.top - pageBounds.top,
                    width: rect.width,
                    height: rect.height
                }
            };
        }

        function saveHighlights() {
            localStorage.setItem('pdfHighlights', JSON.stringify(highlights));
        }

        function loadHighlights() {
            const savedHighlights = JSON.parse(localStorage.getItem('pdfHighlights')) || [];
            highlights = savedHighlights;
            renderHighlights();
        }

        function renderHighlights() {
            if (highlights && highlights.length > 0) {
                highlights.forEach(highlight => {
                    const pageDiv = document.querySelector(`.page[data-page-number="${highlight.pageNumber}"]`);
                    if (pageDiv) {
                        const newHighlight = document.createElement('div');
                        newHighlight.className = 'highlight';
                        newHighlight.style.position = 'absolute';
                        newHighlight.style.backgroundColor = 'rgba(255, 255, 0, 0.3)';
                        newHighlight.style.pointerEvents = 'none';

                        const pageBounds = pageDiv.getBoundingClientRect();
                        const scale = parseFloat(pageDiv.style.width) / pageBounds.width;

                        if (highlight.rects && highlight.rects.length > 0) {
                            highlight.rects.forEach(rect => {
                                const highlightRect = document.createElement('div');
                                highlightRect.style.position = 'absolute';
                                highlightRect.style.left = (rect.left * scale) + 'px';
                                highlightRect.style.top = (rect.top * scale) + 'px';
                                highlightRect.style.width = (rect.width * scale) + 'px';
                                highlightRect.style.height = (rect.height * scale) + 'px';
                                highlightRect.style.backgroundColor = 'inherit';
                                newHighlight.appendChild(highlightRect);
                            });
                        }

                        pageDiv.appendChild(newHighlight);
                    }
                });
            }
        }

        function getPhrase(range, word) {
            let startNode = range.startContainer;
            let endNode = range.endContainer;
            let startOffset = Math.max(0, range.startOffset - 50);
            let endOffset = Math.min(endNode.length, range.endOffset + 50);

            // Extract the phrase
            let phrase = '';
            let currentNode = startNode;
            while (currentNode) {
                if (currentNode.nodeType === Node.TEXT_NODE) {
                    const text = currentNode.textContent;
                    const start = currentNode === startNode ? startOffset : 0;
                    const end = currentNode === endNode ? endOffset : text.length;
                    phrase += text.slice(start, end);
                }
                if (currentNode === endNode) break;
                currentNode = currentNode.nextSibling;
            }
            return phrase.trim();
        }

        function saveLanguageChoice(language) {
            localStorage.setItem('selectedLanguage', language);
        }

        function loadLanguageChoice() {
            return localStorage.getItem('selectedLanguage') || 'English';
        }

        function setLanguageButton(language) {
            const languageButton = document.querySelector(`#language-buttons .mode-btn[data-language="${language}"]`);
            if (languageButton) {
                languageButtons.forEach(btn => btn.classList.remove('selected'));
                languageButton.classList.add('selected');
            }
        }

        submitBtn.addEventListener('click', generateContent);

        apiKeyInput.addEventListener('change', function () {
            apiKey = this.value;
            localStorage.setItem('lastWorkingAPIKey', apiKey);
        });

        // Load last working API key
        const lastWorkingAPIKey = localStorage.getItem('lastWorkingAPIKey');
        if (lastWorkingAPIKey) {
            apiKeyInput.value = lastWorkingAPIKey;
            apiKey = lastWorkingAPIKey;
        }

        // Infinite scrolling and page number update
        let lastScrollTop = 0;
        document.getElementById('left-panel').addEventListener('scroll', function () {
            const st = this.scrollTop;
            const threshold = 100; // Adjust this value to change the scroll sensitivity

            if (st > lastScrollTop) {
                // Scrolling down
                if (this.scrollTop + this.clientHeight >= this.scrollHeight - 500) {
                    if (pageNum < pdfDoc.numPages) {
                        pageNum++;
                        renderPage(pageNum);
                    }
                }
            } else if (st < lastScrollTop - threshold) {
                // Scrolling up
                const pages = document.querySelectorAll('.page');
                for (let i = 0; i < pages.length; i++) {
                    const rect = pages[i].getBoundingClientRect();
                    if (rect.top >= 0) {
                        pageNum = parseInt(pages[i].dataset.pageNumber);
                        break;
                    }
                }
            }

            lastScrollTop = st <= 0 ? 0 : st;
            
            // Update the page number in the "Go to page" box
            document.getElementById('page-input').value = pageNum;
            document.getElementById('current-page').textContent = `Page: ${pageNum}`;
        });

        function loadRecentFiles() {
            fetch('/get_recent_files')
                .then(response => response.json())
                .then(recentFiles => {
                    const fileList = document.getElementById('file-list');
                    fileList.innerHTML = '';
                    recentFiles.forEach(file => {
                        const li = document.createElement('li');
                        li.style.marginBottom = '10px'; // Add spacing between list items
                        const a = document.createElement('a');
                        a.href = '#';
                        const progress = localStorage.getItem(`progress_${file.filename}`) || '0';
                        const truncatedFilename = file.filename.length > 20 ? file.filename.substring(0, 20) + '...' : file.filename;
                        let lastOpenedDate;
                        try {
                            lastOpenedDate = new Date(file.date).toLocaleString();
                        } catch (error) {
                            console.error('Error parsing date:', error);
                            lastOpenedDate = 'Unknown';
                        }
                        a.textContent = `${truncatedFilename} - ${progress}%`;
                        const dateSpan = document.createElement('span');
                        dateSpan.textContent = ` (Last opened: ${lastOpenedDate})`;
                        dateSpan.style.fontSize = '0.8em';
                        dateSpan.style.color = '#666';
                        a.addEventListener('click', function (e) {
                            e.preventDefault();
                            fetch(`/open_pdf/${file.filename}`)
                                .then(response => response.blob())
                                .then(blob => {
                                    const fileType = file.filename.toLowerCase().endsWith('.pdf') ? 'application/pdf' : 
                                                     file.filename.toLowerCase().endsWith('.epub') ? 'application/epub+zip' : 'text/plain';
                                    const newFile = new File([blob], file.filename, { type: fileType });
                                    loadFile(newFile);
                                })
                                .catch(error => console.error('Error:', error));
                        });
                        li.appendChild(a);
                        li.appendChild(dateSpan);
                        fileList.appendChild(li);
                    });
                })
                .catch(error => console.error('Error loading recent files:', error));
        }

        // Call loadRecentFiles when the page loads
        window.addEventListener('load', loadRecentFiles);

        // Update recent files list after uploading a new file
        function uploadFile(file) {
            const formData = new FormData();
            formData.append('file', file);

            fetch('/upload_pdf', {
                method: 'POST',
                body: formData
            })
                .then(response => response.json())
                .then(data => {
                    if (data.message) {
                        console.log(data.message);
                        loadFile(file);
                        loadRecentFiles(); // Reload the recent files list
                    } else {
                        console.error(data.error);
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                });
        }

        // Update loadFile function to reload recent files list
        let book;
        let rendition;
        let currentScale = 100;

        function loadFile(file) {
            const pdfViewer = document.getElementById('pdf-viewer');
            const epubViewer = document.getElementById('epub-viewer');
            const epubControls = document.getElementById('epub-controls');

            // Hide both viewers and controls initially
            pdfViewer.style.display = 'none';
            epubViewer.style.display = 'none';
            epubControls.style.display = 'none';

            if (file.name.toLowerCase().endsWith('.pdf')) {
                pdfViewer.style.display = 'block';
                loadPDF(file);
            } else if (file.name.toLowerCase().endsWith('.txt')) {
                pdfViewer.style.display = 'block';
                loadTXT(file);
            } else if (file.name.toLowerCase().endsWith('.epub')) {
                epubViewer.style.display = 'block';
                epubControls.style.display = 'block';
                loadEPUB(file);
            }
        }

        function loadEPUB(file) {
            const reader = new FileReader();
            reader.onload = function (e) {
                const arrayBuffer = e.target.result;
                book = ePub(arrayBuffer);

                rendition = book.renderTo("epub-viewer", {
                    width: "100%",
                    height: "100%",
                    spread: "always"
                });

                rendition.display();

                book.ready.then(() => {
                    const next = document.getElementById("next-btn");
                    next.addEventListener("click", () => {
                        rendition.next();
                    }, false);

                    const prev = document.getElementById("prev-btn");
                    prev.addEventListener("click", () => {
                        rendition.prev();
                    }, false);

                    rendition.on("relocated", (location) => {
                        const currentLocation = document.getElementById("current-location");
                        const currentPage = location.start.displayed.page;
                        const totalPages = book.packaging.metadata.numberOfPages;
                        currentLocation.textContent = `Page ${currentPage} of ${totalPages}`;
                        updateProgressBar(currentPage);
                    });
                });
            };
            reader.readAsArrayBuffer(file);
        }

        function setupNavigation() {
            const prevBtn = document.getElementById('prev-btn');
            const nextBtn = document.getElementById('next-btn');
            const zoomInBtn = document.getElementById('zoom-in-btn');
            const zoomOutBtn = document.getElementById('zoom-out-btn');

            if (prevBtn) prevBtn.onclick = prevPage;
            if (nextBtn) nextBtn.onclick = nextPage;
            if (zoomInBtn) zoomInBtn.onclick = zoomIn;
            if (zoomOutBtn) zoomOutBtn.onclick = zoomOut;

            // Enable keyboard navigation
            document.addEventListener('keydown', handleKeyPress);
        }

        function prevPage() {
            if (rendition) rendition.prev();
        }

        function nextPage() {
            if (rendition) rendition.next();
        }

        function zoomIn() {
            if (rendition) {
                currentScale += 10;
                setZoom();
            }
        }

        function zoomOut() {
            if (rendition) {
                currentScale -= 10;
                if (currentScale < 50) currentScale = 50; // Prevent zooming out too much
                setZoom();
            }
        }

        function setZoom() {
            if (rendition) {
                rendition.themes.fontSize(`${currentScale}%`);
            }
        }

        function handleKeyPress(e) {
            switch (e.key) {
                case "ArrowLeft":
                    prevPage();
                    break;
                case "ArrowRight":
                    nextPage();
                    break;
                case "+":
                    zoomIn();
                    break;
                case "-":
                    zoomOut();
                    break;
            }
        }

        // Save current page and check for unsaved flashcards before unloading
        window.addEventListener('beforeunload', function (e) {
            if (currentFileName) {
                localStorage.setItem(`lastPage_${currentFileName}`, pageNum);
            }

            const unsavedFlashcards = document.querySelectorAll('.flashcard:not(.in-collection)');
            if (unsavedFlashcards.length > 0) {
                e.preventDefault(); // Cancel the event
                e.returnValue = ''; // Display a default message in most browsers
                return 'You have unsaved flashcards. Are you sure you want to leave?'; // Custom message (may not be displayed in some browsers)
            }
        });

        // Initialize recent PDFs list
        window.onload = function () {
            loadRecentFiles();

            // Add event listener for settings icon
            document.getElementById('settings-icon').addEventListener('click', function () {
                const settingsPanel = document.getElementById('settings-panel');
                settingsPanel.style.display = settingsPanel.style.display === 'none' ? 'block' : 'none';
            });

            // Set default language to English if not already set
            if (!localStorage.getItem('selectedLanguage')) {
                saveLanguageChoice('English');
            }

            // Load and set the saved language choice
            const savedLanguage = loadLanguageChoice();
            setLanguageButton(savedLanguage);
        };

        fileInput.addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (file.type !== 'application/pdf' && file.type !== 'text/plain' && file.type !== 'application/epub+zip') {
                console.error('Error: Not a PDF, TXT, or EPUB file');
                return;
            }
            uploadFile(file);
        });

        function uploadFile(file) {
            const formData = new FormData();
            formData.append('file', file);

            fetch('/upload_file', {
                method: 'POST',
                body: formData
            })
                .then(response => response.json())
                .then(data => {
                    if (data.message) {
                        console.log(data.message);
                        loadFile(file);
                        loadRecentFiles();
                        addRecentFile(file.name);
                    } else {
                        console.error(data.error);
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                });
        }
    </script>
</body>

</html>
