<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Viewer with Flashcard Generation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.9.359/pdf.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        #top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background-color: #f0f0f0;
            border-bottom: 1px solid #ccc;
        }

        #page-navigation {
            display: flex;
            align-items: center;
        }

        #current-page {
            margin-right: 10px;
        }

        #page-input {
            width: 60px;
            margin-right: 5px;
        }

        #left-panel {
            flex-grow: 1;
            width: 80%;
            overflow-y: auto;
            padding: 20px;
            box-sizing: border-box;
        }

        #right-panel {
            width: 20%;
            height: calc(100vh - 50px);
            position: fixed;
            right: 0;
            top: 50px;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
            background-color: #f0f0f0;
        }

        #file-input,
        #mode-toggle,
        #api-key-input,
        #quality-toggle {
            margin-bottom: 10px;
            width: 100%;
        }

        #pdf-viewer {
            border: 1px solid #ccc;
        }

        .page {
            position: relative;
            margin-bottom: 10px;
        }

        .text-layer {
            position: absolute;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            opacity: 0.2;
            line-height: 1.0;
        }

        .text-layer>span {
            color: transparent;
            position: absolute;
            white-space: pre;
            cursor: text;
            transform-origin: 0% 0%;
        }

        ::selection {
            background: rgba(0, 0, 255, 0.3);
        }

        .highlight {
            background-color: #ffff00;
            mix-blend-mode: multiply;
        }

        #system-prompt {
            width: 100%;
            height: 150px;
            margin-bottom: 10px;
        }

        #submit-btn {
            width: 100%;
            margin-bottom: 10px;
        }

        #flashcards {
            border: 1px solid #ccc;
            padding: 10px;
            margin-top: 10px;
            background-color: white;
        }

        .flashcard {
            margin-bottom: 10px;
            padding: 5px;
            border: 1px solid #ddd;
            background-color: white;
        }

        .remove-btn {
            float: right;
        }

        #recent-pdfs {
            margin-top: 10px;
        }

        #recent-pdfs ul {
            padding-left: 20px;
        }
    </style>
</head>

<body>
    <div id="top-bar">
        <input type="file" id="file-input">
        <div id="page-navigation">
            <span id="current-page">Page: 1</span>
            <input type="number" id="page-input" min="1" placeholder="Go to page">
            <button id="go-to-page-btn">Go</button>
        </div>
    </div>
    <div id="left-panel">
        <div id="pdf-viewer"></div>
    </div>
    <div id="right-panel">
        <input type="password" id="api-key-input" placeholder="Enter Claude API Key">
        <select id="model-select">
            <option value="claude-3-5-sonnet-20240620">Claude 3 Sonnet</option>
            <option value="claude-3-haiku-20240307">Claude 3 Haiku</option>
        </select>
        <select id="mode-toggle">
            <option value="flashcard">Flashcard Mode</option>
            <option value="highlight">Highlight Mode</option>
        </select>
        <label><input type="checkbox" id="quality-toggle" checked> High Quality</label>
        <textarea id="system-prompt" placeholder="Enter system prompt for flashcard generation">Generate concise flashcards based on the following text. The number of flashcards should be proportional to the text's length and complexity, with a minimum of 1 and a maximum of 10. Each flashcard should have a question (Q:) that tests a key concept and an answer (A:) that is brief but complete. Ensure that the flashcards cover different aspects of the text when possible. Use <b> tags to emphasize important words or phrases in both questions and answers.

Example:
Text: "The mitochondrion is often described as the powerhouse of the cell because it generates most of the cell's supply of adenosine triphosphate (ATP), used as a source of chemical energy. Mitochondria are found in nearly all eukaryotic organisms and vary in number and location according to cell type."

Q: What is the <b>primary function</b> of mitochondria in cells?
A: To generate <b>ATP</b>, the main source of <b>cellular energy</b>.
Q: In which <b>types of organisms</b> are mitochondria typically found?
A: In nearly all <b>eukaryotic organisms</b>.
Q: How do mitochondria <b>vary</b> among different cell types?
A: They vary in <b>number and location</b> according to the <b>cell type</b>.

Now generate flashcards for this text:</textarea>
        <button id="submit-btn">Generate Flashcard</button>
        <div id="flashcards"></div>
        <div id="tampon">
            <button id="add-to-tampon-btn">Add to Tampon (<span id="tampon-count">0</span>)</button>
            <button id="clear-tampon-btn">Clear Tampon</button>
        </div>
        <button id="export-csv-btn" style="display: none;">Export Flashcards to CSV</button>
        <div id="recent-pdfs">
            <h3>Recent PDFs</h3>
            <ul id="pdf-list"></ul>
        </div>
    </div>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.9.359/pdf.worker.min.js';

        const fileInput = document.getElementById('file-input');
        const pdfViewer = document.getElementById('pdf-viewer');
        const qualityToggle = document.getElementById('quality-toggle');
        const modeToggle = document.getElementById('mode-toggle');
        const systemPrompt = document.getElementById('system-prompt');
        const submitBtn = document.getElementById('submit-btn');
        const flashcardsContainer = document.getElementById('flashcards');
        const apiKeyInput = document.getElementById('api-key-input');
        const modelSelect = document.getElementById('model-select');
        const recentPdfList = document.getElementById('recent-pdf-list');

        let pdfDoc = null;
        let pageNum = 1;
        let pageRendering = false;
        let pageNumPending = null;
        let scale = 1.5;
        let isHighQuality = true;
        let mode = 'flashcard';
        let apiKey = '';
        let currentFileName = '';
        let currentPage = 1;
        let selectedModel = 'claude-3-haiku-20240307';

        function getScale() {
            return isHighQuality ? scale * 2 : scale;
        }

        function renderPage(num) {
            pageRendering = true;
            pdfDoc.getPage(num).then(function (page) {
                const viewport = page.getViewport({ scale: getScale() });
                const pixelRatio = window.devicePixelRatio || 1;
                const adjustedScale = isHighQuality ? getScale() : getScale() * pixelRatio;
                const adjustedViewport = page.getViewport({ scale: adjustedScale });

                const pageDiv = document.createElement('div');
                pageDiv.className = 'page';
                pageDiv.dataset.pageNumber = num;
                pageDiv.style.width = `${viewport.width}px`;
                pageDiv.style.height = `${viewport.height}px`;

                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.height = adjustedViewport.height;
                canvas.width = adjustedViewport.width;
                canvas.style.width = `${viewport.width}px`;
                canvas.style.height = `${viewport.height}px`;

                const renderContext = {
                    canvasContext: ctx,
                    viewport: adjustedViewport,
                    enableWebGL: true,
                    renderInteractiveForms: true,
                };

                const renderTask = page.render(renderContext);

                renderTask.promise.then(function () {
                    pageRendering = false;
                    if (pageNumPending !== null) {
                        renderPage(pageNumPending);
                        pageNumPending = null;
                    }
                });

                pageDiv.appendChild(canvas);

                // Text layer
                const textLayerDiv = document.createElement('div');
                textLayerDiv.className = 'text-layer';
                textLayerDiv.style.width = `${viewport.width}px`;
                textLayerDiv.style.height = `${viewport.height}px`;
                pageDiv.appendChild(textLayerDiv);

                page.getTextContent().then(function (textContent) {
                    pdfjsLib.renderTextLayer({
                        textContent: textContent,
                        container: textLayerDiv,
                        viewport: viewport,
                        textDivs: []
                    });
                });

                pdfViewer.appendChild(pageDiv);

                // Check if we need to load more pages
                if (num < pdfDoc.numPages && pdfViewer.scrollHeight <= window.innerHeight * 2) {
                    renderPage(num + 1);
                }
            });
        }

        function loadPDF(file) {
            const fileReader = new FileReader();
            fileReader.onload = function () {
                const typedarray = new Uint8Array(this.result);

                pdfjsLib.getDocument(typedarray).promise.then(function (pdf) {
                    pdfDoc = pdf;
                    pdfViewer.innerHTML = '';
                    currentFileName = file.name;
                    const lastPage = localStorage.getItem(`lastPage_${currentFileName}`);
                    pageNum = lastPage ? parseInt(lastPage) : 1;
                    renderPage(pageNum);
                    updateCurrentPage(pageNum);
                });
            };
            fileReader.readAsArrayBuffer(file);
        }

        function goToPage(num) {
            if (num >= 1 && num <= pdfDoc.numPages) {
                pageNum = num;
                pdfViewer.innerHTML = '';
                renderPage(pageNum);
                updateCurrentPage(pageNum);
                localStorage.setItem(`lastPage_${currentFileName}`, pageNum);
            } else {
                alert('Invalid page number');
            }
        }

        function updateCurrentPage(num) {
            if (num !== currentPage) {
                currentPage = num;
                document.getElementById('current-page').textContent = `Page: ${num}`;
                document.getElementById('page-input').value = num;
                localStorage.setItem(`lastPage_${currentFileName}`, num);
            }
        }

        // Infinite scrolling with page tracking
        document.getElementById('left-panel').addEventListener('scroll', function () {
            if (this.scrollTop + this.clientHeight >= this.scrollHeight - 500) {
                if (pageNum < pdfDoc.numPages) {
                    pageNum++;
                    renderPage(pageNum);
                }
            }

            // Update current page based on scroll position
            const pages = document.querySelectorAll('.page');
            for (let i = 0; i < pages.length; i++) {
                const page = pages[i];
                const rect = page.getBoundingClientRect();
                if (rect.top >= 0 && rect.bottom <= window.innerHeight) {
                    const newPageNum = parseInt(page.dataset.pageNumber);
                    updateCurrentPage(newPageNum);
                    break;
                }
            }
        });

        function highlight(event) {
            if (mode !== 'highlight') return;

            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                const highlightSpan = document.createElement('span');
                highlightSpan.className = 'highlight';

                if (range.commonAncestorContainer.closest('.text-layer')) {
                    try {
                        range.surroundContents(highlightSpan);
                    } catch (e) {
                        console.error("Highlighting failed:", e);
                        const textNodes = getTextNodesInRange(range);
                        textNodes.forEach(node => {
                            const nodeRange = document.createRange();
                            nodeRange.selectNodeContents(node);
                            nodeRange.surroundContents(highlightSpan.cloneNode(true));
                        });
                    }
                }
            }
            selection.removeAllRanges();
        }

        function getTextNodesInRange(range) {
            const textNodes = [];
            const treeWalker = document.createTreeWalker(
                range.commonAncestorContainer,
                NodeFilter.SHOW_TEXT,
                { acceptNode: node => range.intersectsNode(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT }
            );
            while (treeWalker.nextNode()) {
                textNodes.push(treeWalker.currentNode);
            }
            return textNodes;
        }

        async function generateFlashcard() {
            if (!apiKey) {
                alert('Please enter your Claude API key first.');
                return;
            }

            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const selectedText = selection.toString();
                const prompt = `${systemPrompt.value}\n\n${selectedText}`;

                try {
                    const response = await callClaudeAPI(prompt);
                    displayFlashcards(response.flashcards, true); // Append new flashcards
                } catch (error) {
                    console.error('Error calling Claude API:', error);
                    alert('Failed to generate flashcards. Please check your API key and try again.');
                }
            } else {
                alert('Please select some text from the PDF to generate flashcards.');
            }
        }

        async function callClaudeAPI(prompt) {
            const response = await fetch('/generate_flashcard', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-API-Key': apiKey
                },
                body: JSON.stringify({ 
                    prompt: prompt,
                    model: selectedModel
                })
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            return await response.json();
        }

        modelSelect.addEventListener('change', function () {
            selectedModel = this.value;
        });

        function displayFlashcards(flashcards, append = false) {
            if (!append) {
                flashcardsContainer.innerHTML = ''; // Clear existing flashcards only if not appending
            }
            flashcards.forEach(flashcard => {
                const flashcardElement = document.createElement('div');
                flashcardElement.className = 'flashcard';
                flashcardElement.innerHTML = `
                    <strong>Q: ${flashcard.question}</strong><br>
                    A: ${flashcard.answer}
                    <button class="remove-btn">Remove</button>
                `;
                flashcardElement.querySelector('.remove-btn').addEventListener('click', function () {
                    flashcardElement.remove();
                    updateExportButtonVisibility();
                });
                flashcardsContainer.appendChild(flashcardElement);
            });
            updateExportButtonVisibility();
        }

        function updateExportButtonVisibility() {
            const exportButton = document.getElementById('export-csv-btn');
            exportButton.style.display = flashcardsContainer.children.length > 0 ? 'block' : 'none';
        }

        function exportToCSV() {
            const flashcards = document.querySelectorAll('.flashcard');
            <!-- let csvContent = "data:text/csv;charset=utf-8,Question,Answer\n"; -->
            let csvContent = "data:text/csv;charset=utf-8,";

            flashcards.forEach(flashcard => {
                const question = flashcard.querySelector('strong').textContent.slice(3);
                const answer = flashcard.innerHTML.split('<br>')[1].split('<button')[0].trim().slice(3);
                csvContent += `"${question}","${answer}"\n`;
            });

            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "flashcards.csv");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        document.getElementById('export-csv-btn').addEventListener('click', exportToCSV);

        function addRecentPDF(filename) {
            let recentPDFs = JSON.parse(localStorage.getItem('recentPDFs')) || [];
            recentPDFs = recentPDFs.filter(pdf => pdf.filename !== filename);
            recentPDFs.unshift({ filename: filename, date: new Date().toISOString() });
            recentPDFs = recentPDFs.slice(0, 5);  // Keep only the 5 most recent
            localStorage.setItem('recentPDFs', JSON.stringify(recentPDFs));
            updateRecentPDFsList();
        }

        function updateRecentPDFsList() {
            const recentPDFs = JSON.parse(localStorage.getItem('recentPDFs')) || [];
            recentPdfList.innerHTML = '';
            recentPDFs.forEach(pdf => {
                const li = document.createElement('li');
                li.textContent = `${pdf.filename} (${new Date(pdf.date).toLocaleDateString()})`;
                recentPdfList.appendChild(li);
            });
        }

        fileInput.addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (file.type !== 'application/pdf') {
                console.error('Error: Not a PDF file');
                return;
            }
            loadPDF(file);
            addRecentPDF(file.name);
        });

        document.getElementById('go-to-page-btn').addEventListener('click', function() {
            const pageInput = document.getElementById('page-input');
            const pageNumber = parseInt(pageInput.value);
            goToPage(pageNumber);
        });

        qualityToggle.addEventListener('change', function () {
            isHighQuality = this.checked;
            if (pdfDoc) {
                pdfViewer.innerHTML = '';
                pageNum = 1;
                renderPage(pageNum);
            }
        });

        modeToggle.addEventListener('change', function () {
            mode = this.value;
            pdfViewer.style.cursor = mode === 'highlight' ? 'crosshair' : 'default';
        });

        pdfViewer.addEventListener('mouseup', highlight);

        submitBtn.addEventListener('click', generateFlashcard);

        apiKeyInput.addEventListener('change', function () {
            apiKey = this.value;
            localStorage.setItem('lastWorkingAPIKey', apiKey);
        });

        // Load last working API key
        const lastWorkingAPIKey = localStorage.getItem('lastWorkingAPIKey');
        if (lastWorkingAPIKey) {
            apiKeyInput.value = lastWorkingAPIKey;
            apiKey = lastWorkingAPIKey;
        }

        // Infinite scrolling
        document.getElementById('left-panel').addEventListener('scroll', function () {
            if (this.scrollTop + this.clientHeight >= this.scrollHeight - 500) {
                if (pageNum < pdfDoc.numPages) {
                    pageNum++;
                    renderPage(pageNum);
                }
            }
        });

        function loadRecentPDFs() {
            const recentPDFs = {{ recent_pdfs|tojson }};
            const pdfList = document.getElementById('pdf-list');
            pdfList.innerHTML = '';
            recentPDFs.forEach(pdf => {
                const li = document.createElement('li');
                const a = document.createElement('a');
                a.href = '#';
                a.textContent = `${pdf.filename} (${new Date(pdf.date).toLocaleDateString()})`;
                a.addEventListener('click', function(e) {
                    e.preventDefault();
                    fetch(`/open_pdf/${pdf.filename}`)
                        .then(response => response.blob())
                        .then(blob => {
                            const file = new File([blob], pdf.filename, { type: 'application/pdf' });
                            loadPDF(file);
                        })
                        .catch(error => console.error('Error:', error));
                });
                li.appendChild(a);
                pdfList.appendChild(li);
            });
        }

        // Save current page before unloading
        window.addEventListener('beforeunload', function() {
            if (currentFileName) {
                localStorage.setItem(`lastPage_${currentFileName}`, pageNum);
            }
        });

        // Initialize recent PDFs list
        window.onload = loadRecentPDFs;

        fileInput.addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (file.type !== 'application/pdf') {
                console.error('Error: Not a PDF file');
                return;
            }
            uploadPDF(file);
        });

        function uploadPDF(file) {
            const formData = new FormData();
            formData.append('file', file);

            fetch('/upload_pdf', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.message) {
                    console.log(data.message);
                    loadPDF(file);
                    loadRecentPDFs();
                } else {
                    console.error(data.error);
                }
            })
            .catch(error => {
                console.error('Error:', error);
            });
        }
    </script>
</body>

</html>
