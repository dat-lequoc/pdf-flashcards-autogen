<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document Viewer with Flashcard Generation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.9.359/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js"></script>
    <link rel="stylesheet" href="/static/css/styles.css">
    <script src="/static/js/prompts.js"></script>
    <script src="/static/js/models.js"></script>
</head>

<body>
    <div id="top-bar">
        <input type="file" id="file-input" accept=".pdf,.txt,.epub">
        <span id="current-page">Page: 1</span>
    </div>
    <div id="left-panel">
        <div id="pdf-viewer"></div>
        <div id="epub-viewer"></div>
    </div>
    <div id="right-panel">
        <div id="top-controls">
            <div id="settings-icon">‚öôÔ∏è</div>
            <div id="dark-mode-toggle">üåô</div>
            <div id="page-navigation">
                <button id="zoom-out-btn">-</button>
                <button id="zoom-in-btn">+</button>
                <input type="number" id="page-input" min="1" placeholder="Page #">
                <button id="go-to-page-btn">Go</button>
            </div>
        </div>
        <div id="settings-panel" style="display: none;">
            <input type="password" id="api-key-input" placeholder="Enter API Key">
            <select id="model-select"></select>
            <textarea id="system-prompt" placeholder="Enter system prompt for flashcard generation"></textarea>
            <textarea id="explain-prompt" placeholder="Enter system prompt for explanation" style="display: none;"></textarea>
            <textarea id="language-prompt" placeholder="Enter system prompt for language mode"></textarea>
            <div id="language-buttons" style="display: none; margin-top: 10px;">
                <button class="mode-btn" data-language="English">English</button>
                <button class="mode-btn" data-language="French">French</button>
            </div>
        </div>
        <div id="mode-toggle">
            <button class="mode-btn selected" data-mode="flashcard">Flashcard</button>
            <button class="mode-btn" data-mode="explain">Explain</button>
            <button class="mode-btn" data-mode="language">Language</button>
        </div>
        <button id="submit-btn" style="display: block;">Generate</button>
        <div id="flashcards"></div>
        <div class="dropdown" id="collection-dropdown">
            <button class="dropbtn" id="collection-dropbtn">Collection Options</button>
            <div class="dropdown-content" id="collection-dropdown-content">
                <a href="#" id="add-to-collection-option">Add to Collection (0)</a>
                <a href="#" id="clear-collection-option">Clear Collection</a>
                <a href="#" id="export-csv-option" style="display: none;">Export Flashcards to CSV</a>
                <a href="#" id="export-json-option" style="display: none;">Export Flashcards to JSON</a>
            </div>
        </div>
        <div id="recent-files">
            <h3>Recent Files</h3>
            <ul id="file-list"></ul>
        </div>
        <div id="highlight-instruction" style="font-size: 0.7em; color: #666; position: absolute; bottom: 5px; right: 5px;">Use Alt+Select to highlight text</div>
    </div>

    <!-- Explanation Modal -->
    <div id="explanationModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <div id="explanationModalContent"></div>
        </div>
    </div>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.9.359/pdf.worker.min.js';

        const fileInput = document.getElementById('file-input');
        const pdfViewer = document.getElementById('pdf-viewer');
        const modeToggle = document.getElementById('mode-toggle');
        const systemPrompt = document.getElementById('system-prompt');
        const submitBtn = document.getElementById('submit-btn');
        const flashcardsContainer = document.getElementById('flashcards');
        const apiKeyInput = document.getElementById('api-key-input');
        const modelSelect = document.getElementById('model-select');
        const recentPdfList = document.getElementById('recent-pdf-list');

        let pdfDoc = null;
        let pageNum = 1;
        let pageRendering = false;
        let pageNumPending = null;
        let scale = 3;
        const minScale = 0.5;
        const maxScale = 5;
        let mode = 'flashcard';
        let apiKey = '';
        let currentFileName = '';
        let currentPage = 1;
        let selectedModel = 'gemini/gemini-exp-1206';
        let lastProcessedQuery = '';
        let lastRequestTime = 0;
        const cooldownTime = 1000; // 1 second cooldown

        function renderPage(num) {
            pageRendering = true;
            pdfDoc.getPage(num).then(function (page) {
                const viewport = page.getViewport({ scale: scale });
                const pixelRatio = window.devicePixelRatio || 1;
                const adjustedViewport = page.getViewport({ scale: scale * pixelRatio });

                const pageDiv = document.createElement('div');
                pageDiv.className = 'page';
                pageDiv.dataset.pageNumber = num;
                pageDiv.style.width = `${viewport.width}px`;
                pageDiv.style.height = `${viewport.height}px`;

                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.height = adjustedViewport.height;
                canvas.width = adjustedViewport.width;
                canvas.style.width = `${viewport.width}px`;
                canvas.style.height = `${viewport.height}px`;

                const renderContext = {
                    canvasContext: ctx,
                    viewport: adjustedViewport,
                    enableWebGL: true,
                    renderInteractiveForms: true,
                };

                const renderTask = page.render(renderContext);

                renderTask.promise.then(function () {
                    pageRendering = false;
                    if (pageNumPending !== null) {
                        renderPage(pageNumPending);
                        pageNumPending = null;
                    }
                });

                pageDiv.appendChild(canvas);

                // Text layer
                const textLayerDiv = document.createElement('div');
                textLayerDiv.className = 'text-layer';
                textLayerDiv.style.width = `${viewport.width}px`;
                textLayerDiv.style.height = `${viewport.height}px`;
                pageDiv.appendChild(textLayerDiv);

                page.getTextContent().then(function (textContent) {
                    pdfjsLib.renderTextLayer({
                        textContent: textContent,
                        container: textLayerDiv,
                        viewport: viewport,
                        textDivs: []
                    });
                });

                pdfViewer.appendChild(pageDiv);

                // Attach language mode listener to the new page
                attachLanguageModeListener(pageDiv);

                // Render highlights for this page
                renderHighlights();

                // Check if we need to load more pages
                if (num < pdfDoc.numPages && pdfViewer.scrollHeight <= window.innerHeight * 2) {
                    renderPage(num + 1);
                }
            });
        }

        function loadFile(file) {
            if (file.name.endsWith('.pdf')) {
                loadPDF(file);
            } else if (file.name.endsWith('.txt')) {
                loadTXT(file);
            }
        }

        function loadPDF(file) {
            const fileReader = new FileReader();
            fileReader.onload = function () {
                const typedarray = new Uint8Array(this.result);

                pdfjsLib.getDocument(typedarray).promise.then(function (pdf) {
                    pdfDoc = pdf;
                    pdfViewer.innerHTML = '';
                    currentFileName = file.name;
                    const lastPage = localStorage.getItem(`lastPage_${currentFileName}`);
                    pageNum = lastPage ? Math.max(parseInt(lastPage) - 2, 1) : 1;
                    loadScaleForCurrentFile();
                    renderPage(pageNum);
                    updateCurrentPage(pageNum);
                    hideHeaderPanel();
                    loadHighlights();
                });
            };
            fileReader.readAsArrayBuffer(file);
        }

        function loadTXT(file) {
            const fileReader = new FileReader();
            fileReader.onload = function () {
                const content = this.result;
                pdfViewer.innerHTML = '';
                currentFileName = file.name;
                const textContainer = document.createElement('div');
                textContainer.className = 'text-content';
                textContainer.textContent = content;
                pdfViewer.appendChild(textContainer);
                hideHeaderPanel();
        
                // Add event listeners for language mode
                attachLanguageModeListener(textContainer);
            };
            fileReader.readAsText(file);
        }

        function hideHeaderPanel() {
            document.getElementById('top-bar').style.display = 'none';
        }

        function goToPage(num) {
            if (num >= 1 && num <= pdfDoc.numPages) {
                pageNum = num;
                pdfViewer.innerHTML = '';  // Clear all pages
                renderPage(pageNum);  // Render the selected page
                
                // Also render a few pages after the selected page for better scrolling experience
                for (let i = 1; i <= 2; i++) {
                    if (pageNum + i <= pdfDoc.numPages) {
                        renderPage(pageNum + i);
                    }
                }
                
                updateCurrentPage(pageNum);
                localStorage.setItem(`lastPage_${currentFileName}`, pageNum);
                
                // Scroll to the selected page
                const targetPage = document.querySelector(`.page[data-page-number="${pageNum}"]`);
                if (targetPage) {
                    targetPage.scrollIntoView({ behavior: 'smooth' });
                }
            } else {
                alert('Invalid page number');
            }
        }

        function updateCurrentPage(num) {
            if (num !== currentPage) {
                currentPage = num;
                const currentPageDisplay = document.getElementById('current-page');
                const pageInput = document.getElementById('page-input');
                currentPageDisplay.textContent = `Page: ${num}`;
                pageInput.value = num;
                localStorage.setItem(`lastPage_${currentFileName}`, num);

                // Update progress background for "Go to Page" button based on reading progress.
                if (pdfDoc && pdfDoc.numPages) {
                    const fraction = (num / pdfDoc.numPages) * 100;
                    const goToPageBtn = document.getElementById('go-to-page-btn');
                    goToPageBtn.style.background = `linear-gradient(to right, #28a745 ${fraction}%, var(--secondary-color) ${fraction}%)`;
                }
            }
        }

        // Infinite scrolling with page tracking
        document.getElementById('left-panel').addEventListener('scroll', function () {
            if (this.scrollTop + this.clientHeight >= this.scrollHeight - 500) {
                if (pageNum < pdfDoc.numPages) {
                    pageNum++;
                    renderPage(pageNum);
                }
            }

            // Updated: Update current page based on the center of the viewport
            const pages = document.querySelectorAll('.page');
            const viewportMid = window.innerHeight / 2;
            for (let i = 0; i < pages.length; i++) {
                const page = pages[i];
                const rect = page.getBoundingClientRect();
                if (rect.top < viewportMid && rect.bottom > viewportMid) {
                    const newPageNum = parseInt(page.dataset.pageNumber);
                    updateCurrentPage(newPageNum);
                    break;
                }
            }
        });

        function handleLanguageMode(event, targetLanguage) {
            if (mode !== 'language') return;

            event.preventDefault();
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                const selectedText = selection.toString().trim();
                if (selectedText) {
                    const phrase = getPhrase(range);
                    const currentTime = Date.now();
                    if (phrase !== lastProcessedQuery && currentTime - lastRequestTime >= cooldownTime) {
                        lastProcessedQuery = phrase;
                        lastRequestTime = currentTime;
                        speakWord(selectedText);
                        generateLanguageFlashcard(selectedText, phrase, targetLanguage);
                    }

                }
            }
        }

        let voices = [];

        function populateVoiceList() {
            voices = speechSynthesis.getVoices();
        }

        populateVoiceList();
        if (speechSynthesis.onvoiceschanged !== undefined) {
            speechSynthesis.onvoiceschanged = populateVoiceList;
        }

        function speakWord(word) {
            console.log('Attempting to speak word:', word);
            
            // Cancel any ongoing speech
            window.speechSynthesis.cancel();
            
            // Add a prefix of silence to ensure the beginning doesn't get cut off
            const utterance = new SpeechSynthesisUtterance(". " + word);
            utterance.rate = 0.8;
            utterance.volume = 1.0;
            
            // Ensure we have the latest list of voices
            const currentVoices = window.speechSynthesis.getVoices();
            
            // Look specifically for Microsoft Zira voice
            let ziraVoice = currentVoices.find(voice => 
                voice.name === 'Microsoft Zira - English (United States)'
            );
            
            // If Zira not found, fall back to any English voice
            if (!ziraVoice) {
                ziraVoice = currentVoices.find(voice => voice.lang.startsWith('en-'));
            }
            
            // Fallback to a default voice
            if (!ziraVoice && currentVoices.length > 0) {
                ziraVoice = currentVoices[0];
            }
            
            if (ziraVoice) {
                utterance.voice = ziraVoice;
            }
            
            // Force the audio context to resume if it's suspended
            if (typeof window.AudioContext !== 'undefined' || typeof window.webkitAudioContext !== 'undefined') {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                const audioContext = new AudioContext();
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
            }
            
            // Prepare the speech synthesis system
            setTimeout(() => {
                try {
                    // Speak twice - first with an empty string to "wake up" the speech system
                    const wakeup = new SpeechSynthesisUtterance('');
                    window.speechSynthesis.speak(wakeup);
                    
                    // Then speak the actual word after a slight delay
                    wakeup.onend = () => {
                        window.speechSynthesis.speak(utterance);
                    };
                    
                    // Fallback in case onend doesn't fire
                    setTimeout(() => {
                        if (!utterance.speaking) {
                            window.speechSynthesis.speak(utterance);
                        }
                    }, 100);
                } catch (error) {
                    console.error('Error speaking:', error);
                }
            }, 100);
        }

        function getPhrase(range) {
            const sentenceStart = /[.!?]\s+[A-Z]|^[A-Z]/;
            const sentenceEnd = /[.!?](?=\s|$)/;

            let startNode = range.startContainer;
            let endNode = range.endContainer;
            let startOffset = range.startOffset;
            let endOffset = range.endOffset;

            // Expand to sentence boundaries
            while (startNode && startNode.textContent && !sentenceStart.test(startNode.textContent.slice(0, startOffset))) {
                if (startNode.previousSibling) {
                    startNode = startNode.previousSibling;
                    startOffset = startNode.textContent ? startNode.textContent.length : 0;
                } else if (startNode.parentNode && startNode.parentNode.previousSibling) {
                    startNode = startNode.parentNode.previousSibling.lastChild;
                    startOffset = startNode && startNode.textContent ? startNode.textContent.length : 0;
                } else {
                    break;
                }
            }

            while (endNode && endNode.textContent && !sentenceEnd.test(endNode.textContent.slice(endOffset))) {
                if (endNode.nextSibling) {
                    endNode = endNode.nextSibling;
                    endOffset = 0;
                } else if (endNode.parentNode && endNode.parentNode.nextSibling) {
                    endNode = endNode.parentNode.nextSibling.firstChild;
                    endOffset = 0;
                } else {
                    break;
                }
            }

            // Check if we have valid start and end nodes
            if (startNode && startNode.nodeType === Node.TEXT_NODE &&
                endNode && endNode.nodeType === Node.TEXT_NODE &&
                startNode.textContent && endNode.textContent) {
                const phraseRange = document.createRange();
                phraseRange.setStart(startNode, startOffset);
                phraseRange.setEnd(endNode, endOffset);
                return phraseRange.toString().trim();
            } else {
                // If we don't have valid nodes, return the original selection
                return range.toString().trim();
            }
        }

        function getFullSentence(text, word) {
            const sentenceRegex = /[^.!?]+[.!?]+\s*/g;
            const sentences = text.match(sentenceRegex) || [text];

            const matchingSentences = sentences.filter(sentence =>
                new RegExp(`\\b${word}\\b`, 'i').test(sentence)
            );

            if (matchingSentences.length === 0) {
                const wordIndex = text.indexOf(word);
                if (wordIndex !== -1) {
                    const start = Math.max(0, wordIndex - 30);
                    const end = Math.min(text.length, wordIndex + word.length + 30);
                    return text.slice(start, end);
                }
                return text;
            } else if (matchingSentences.length === 1) {
                // If only one matching sentence, return it
                return matchingSentences[0].trim();
            } else {
                // If multiple matching sentences, return them joined
                return matchingSentences.join(' ').trim();
            }
        }

        async function callLLMAPI(prompt) {
            const response = await fetch('/generate_flashcard', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-API-Key': apiKey
                },
                body: JSON.stringify({
                    prompt: prompt,
                    model: selectedModel,
                    mode: mode
                })
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            return await response.json();
        }

        async function getIPATranscription(word, language) {
            try {
                const response = await fetch('/get_ipa', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        word: word,
                        language: language
                    })
                });
                const data = await response.json();
                return data.ipa;
            } catch (error) {
                console.error(`Error getting IPA for '${word}':`, error);
                return '';
            }
        }

        async function generateLanguageFlashcard(word, phrase, targetLanguage) {
            const prompt = document.getElementById('language-prompt').value
                .replace('{word}', word)
                .replace('{phrase}', phrase)
                .replace('{targetLanguage}', targetLanguage);

            try {
                // Get IPA transcription while waiting for the LLM response
                const ipaPromise = getIPATranscription(word, targetLanguage);
                
                // Get word audio (gTTS) in parallel
                const wordAudioPromise = getAudioPromise(word, 'word', targetLanguage);
                
                // Get phrase audio (Polly) in parallel
                const phraseAudioPromise = getAudioPromise(phrase, 'phrase', targetLanguage);
                
                const response = await callLLMAPI(prompt);
                if (response.flashcard) {
                    const flashcard = response.flashcard;
                    
                    // Wait for all promises to resolve
                    const [ipa, wordAudio, phraseAudio] = await Promise.all([
                        ipaPromise, 
                        wordAudioPromise, 
                        phraseAudioPromise
                    ]);
                    
                    const formattedFlashcard = {
                        question: flashcard.question,
                        answer: flashcard.answer,
                        word: flashcard.word,
                        translation: flashcard.translation,
                        ipa: ipa,
                        wordAudio: wordAudio,
                        phraseAudio: phraseAudio
                    };
                    
                    console.log(formattedFlashcard);
                    displayLanguageFlashcard(formattedFlashcard);
                } else {
                    throw new Error('Invalid response from API');
                }
            } catch (error) {
                console.error('Error calling LLM API:', error);
                alert('Failed to generate language flashcard. Please check your API key and try again.');
            }
        }

        async function getAudioPromise(text, type, language) {
            try {
                const response = await fetch('/get_audio', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        word: text,
                        language: language,
                        type: type
                    })
                });
                const data = await response.json();
                return data.audio || '';
            } catch (error) {
                console.error(`Error getting ${type} audio:`, error);
                return '';
            }
        }

        async function generateContent() {
            const selection = window.getSelection();
            if (selection.rangeCount > 0 && selection.toString().trim() !== '') {
                const selectedText = selection.toString();
                let prompt;

                if (mode === 'flashcard') {
                    prompt = `${systemPrompt.value}\n\n${selectedText}`;
                } else if (mode === 'explain') {
                    const explainPromptValue = document.getElementById('explain-prompt').value;
                    prompt = `${explainPromptValue}\n\n${selectedText}`;
                } else {
                    return;
                }
                
                // Disable the button and show notification
                submitBtn.disabled = true;
                submitBtn.style.backgroundColor = '#808080';
                const notification = document.createElement('div');
                notification.textContent = 'Generating...';
                notification.style.position = 'fixed';
                notification.style.top = '20px';
                notification.style.right = '20px';
                notification.style.padding = '10px';
                notification.style.backgroundColor = 'rgba(0, 128, 0, 0.7)';
                notification.style.color = 'white';
                notification.style.borderRadius = '5px';
                notification.style.zIndex = '1000';
                document.body.appendChild(notification);

                try {
                    const response = await callLLMAPI(prompt);
                    if (mode === 'flashcard' && response.flashcards) {
                        displayFlashcards(response.flashcards, true);
                    } else if (mode === 'explain' && response.explanation) {
                        displayExplanation(response.explanation);
                    } else {
                        throw new Error('Invalid response from API');
                    }
                } catch (error) {
                    console.error('Error calling LLM API:', error);
                    alert(`Failed to generate ${mode === 'flashcard' ? 'flashcards' : 'an explanation'}. Please check your API key and try again.`);
                } finally {
                    setTimeout(() => {
                        document.body.removeChild(notification);
                        submitBtn.disabled = false;
                        submitBtn.style.backgroundColor = '';
                    }, 3000);
                }
            } else {
                alert(`Please select some text to generate ${mode === 'flashcard' ? 'flashcards' : 'an explanation'}.`);
            }
        }

        function displayExplanation(explanation) {
            // Display in right panel
            const explanationElement = document.createElement('div');
            explanationElement.className = 'explanation';
            explanationElement.innerHTML = `
                <h3>Explanation</h3>
                <div class="explanation-content">${explanation}</div>
                <button class="remove-btn">Remove</button>
            `;
            explanationElement.querySelector('.remove-btn').addEventListener('click', function () {
                explanationElement.remove();
            });
            flashcardsContainer.appendChild(explanationElement);

            // Display in modal
            const modal = document.getElementById('explanationModal');
            const modalContent = document.getElementById('explanationModalContent');
            const closeBtn = document.getElementsByClassName('close')[0];

            // Convert markdown to HTML
            const converter = new showdown.Converter();
            const htmlContent = converter.makeHtml(explanation);

            modalContent.innerHTML = htmlContent;
            modal.style.display = 'block';

            closeBtn.onclick = function () {
                modal.style.display = 'none';
            }

            window.onclick = function (event) {
                if (event.target == modal) {
                    modal.style.display = 'none';
                }
            }
        }

        function displayFlashcards(flashcards, append = false) {
            if (!append) {
                flashcardsContainer.innerHTML = ''; // Clear existing flashcards only if not appending
            }
            flashcards.forEach(flashcard => {
                const flashcardElement = document.createElement('div');
                flashcardElement.className = 'flashcard';
                flashcardElement.innerHTML = `
                    <strong>Q: ${flashcard.question}</strong><br>
                    A: ${flashcard.answer}
                    <button class="remove-btn">Remove</button>
                `;
                flashcardElement.querySelector('.remove-btn').addEventListener('click', function () {
                    flashcardElement.remove();
                    updateExportButtonVisibility();
                });
                // Prepend new flashcard to the container to show it at the top
                flashcardsContainer.insertBefore(flashcardElement, flashcardsContainer.firstChild);
            });
            updateExportButtonVisibility();
        }

        function displayLanguageFlashcard(flashcard) {
            const flashcardElement = document.createElement('div');
            flashcardElement.className = 'flashcard language-flashcard';
            flashcardElement.dataset.question = flashcard.question;
            flashcardElement.dataset.word = flashcard.word;
            flashcardElement.dataset.translation = flashcard.translation;
            flashcardElement.dataset.answer = flashcard.answer;
            flashcardElement.dataset.ipa = flashcard.ipa || '';
            // Store audio data in the dataset if available
            flashcardElement.dataset.wordAudio = flashcard.wordAudio || '';
            flashcardElement.dataset.phraseAudio = flashcard.phraseAudio || '';
            
            flashcardElement.innerHTML = `
                    <div style="font-size: 1.2em; margin-bottom: 10px;">
                        <b>${flashcard.word}</b>: ${flashcard.translation} 
                        <button class="pronunciation-btn" title="Listen to pronunciation">üîä</button>
                    </div>
                    <div>- ${flashcard.answer}</div>
                    <button class="remove-btn">Remove</button>
                `;
            
            // Add event listener for pronunciation button
            const pronBtn = flashcardElement.querySelector('.pronunciation-btn');
            pronBtn.addEventListener('click', function() {
                if (flashcard.wordAudio) {
                    playAudio(flashcard.wordAudio);
                } else {
                    getAndPlayAudio(flashcard.word, 'word');
                }
            });
            
            flashcardElement.querySelector('.remove-btn').addEventListener('click', function () {
                flashcardElement.remove();
                updateExportButtonVisibility();
            });
            
            // Prepend new language flashcard at the top of the container
            flashcardsContainer.insertBefore(flashcardElement, flashcardsContainer.firstChild);
            updateExportButtonVisibility();
        }

        function playAudio(base64Audio) {
            const audio = new Audio(`data:audio/mp3;base64,${base64Audio}`);
            audio.play().catch(e => console.error('Error playing audio:', e));
        }

        function getAndPlayAudio(text, type = 'word') {
            const selectedLanguageButton = document.querySelector('#language-buttons .mode-btn.selected');
            const language = selectedLanguageButton ? selectedLanguageButton.dataset.language : 'English';
            
            fetch('/get_audio', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    word: text,
                    language: language,
                    type: type
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.audio) {
                    playAudio(data.audio);
                    
                    // Store the audio in the flashcard for future use
                    const flashcards = document.querySelectorAll('.language-flashcard');
                    flashcards.forEach(card => {
                        if ((type === 'word' && card.dataset.word === text) || 
                            (type === 'phrase' && card.dataset.question === text)) {
                            if (type === 'word') {
                                card.dataset.wordAudio = data.audio;
                            } else {
                                card.dataset.phraseAudio = data.audio;
                            }
                        }
                    });
                } else if (data.error) {
                    console.error('Error getting audio:', data.error);
                }
            })
            .catch(error => console.error('Error:', error));
        }

        let flashcardCollectionCount = 0;
        let languageCollectionCount = 0;
        let collectedFlashcards = [];
        let collectedLanguageFlashcards = [];

        function addToCollection() {
            const newFlashcards = Array.from(document.querySelectorAll('.flashcard:not(.in-collection)')).map(flashcard => {
                if (flashcard.classList.contains('language-flashcard')) {
                    const word = flashcard.dataset.word;
                    const translation = flashcard.dataset.translation;
                    const answer = flashcard.dataset.answer;
                    const question = flashcard.dataset.question;
                    const ipa = flashcard.dataset.ipa || '';
                    const wordAudio = flashcard.dataset.wordAudio || '';
                    const phraseAudio = flashcard.dataset.phraseAudio || '';
                    
                    return {
                        word: word,
                        phrase: question,
                        translationAnswer: `${translation.trim()}\n${answer.trim()}`,
                        ipa: ipa,
                        wordAudio: wordAudio,
                        phraseAudio: phraseAudio
                    };
                } else {
                    const question = flashcard.querySelector('strong').textContent.slice(3);
                    const answer = flashcard.innerHTML.split('<br>')[1].split('<button')[0].trim().slice(3);
                    return {
                        phrase: question,
                        translationAnswer: answer
                    };
                }
            });

            if (mode === 'language') {
                collectedLanguageFlashcards = collectedLanguageFlashcards.concat(newFlashcards);
                updateCollectionCount(newFlashcards.length, 'language');
            } else {
                collectedFlashcards = collectedFlashcards.concat(newFlashcards);
                updateCollectionCount(newFlashcards.length, 'flashcard');
            }
            clearDisplayedFlashcards();
            updateExportButtonVisibility();
        }

        function clearDisplayedFlashcards() {
            flashcardsContainer.innerHTML = '';
        }

        function updateCollectionCount(change, collectionType) {
            if (collectionType === 'language') {
                languageCollectionCount += change;
                localStorage.setItem('languageCollectionCount', languageCollectionCount);
                localStorage.setItem('collectedLanguageFlashcards', JSON.stringify(collectedLanguageFlashcards));
            } else {
                flashcardCollectionCount += change;
                localStorage.setItem('flashcardCollectionCount', flashcardCollectionCount);
                localStorage.setItem('collectedFlashcards', JSON.stringify(collectedFlashcards));
            }
            updateAddToCollectionButtonText();
        }

        function updateAddToCollectionButtonText() {
            var addToCollectionOption = document.getElementById('add-to-collection-option');
            var count = mode === 'language' ? languageCollectionCount : flashcardCollectionCount;
            addToCollectionOption.textContent = `Add to Collection (${count})`;
        }

        // Initialize collection counts and flashcards from localStorage
        flashcardCollectionCount = parseInt(localStorage.getItem('flashcardCollectionCount')) || 0;
        languageCollectionCount = parseInt(localStorage.getItem('languageCollectionCount')) || 0;
        collectedFlashcards = JSON.parse(localStorage.getItem('collectedFlashcards')) || [];
        collectedLanguageFlashcards = JSON.parse(localStorage.getItem('collectedLanguageFlashcards')) || [];
        updateAddToCollectionButtonText();
        updateExportButtonVisibility();

        document.getElementById('add-to-collection-option').addEventListener('click', function(e) {
            e.preventDefault();
            addToCollection();
        });

        function updateExportButtonVisibility() {
            var csvExportOption = document.getElementById('export-csv-option');
            var jsonExportOption = document.getElementById('export-json-option');
            var currentCollection = mode === 'language' ? collectedLanguageFlashcards : collectedFlashcards;
            var count = currentCollection.length;
            
            csvExportOption.style.display = count > 0 ? 'block' : 'none';
            csvExportOption.textContent = `Export Flashcards to CSV (${count})`;
            
            jsonExportOption.style.display = count > 0 ? 'block' : 'none';
            jsonExportOption.textContent = `Export Flashcards to JSONL (${count})`;
        }

        function exportToCSV() {
            let csvContent = "data:text/csv;charset=utf-8,";
            const currentCollection = mode === 'language' ? collectedLanguageFlashcards : collectedFlashcards;
            const removeQuotes = str => str.replace(/"/g, '');

            if (mode === 'language') {
                // Add headers for CSV with new fields
                csvContent += "word;translation;ipa;example;word_audio;phrase_audio\n";
                
                currentCollection.forEach(({ word, translationAnswer, ipa, wordAudio, phraseAudio }) => {
                    const [translation, answer] = translationAnswer.split('\n');
                    csvContent += `${removeQuotes(word)};${removeQuotes(translation)};${ipa || ''};${removeQuotes(answer)};${wordAudio || ''};${phraseAudio || ''}\n`;
                });
            } else {
                csvContent += `question;answer\n`;
                currentCollection.forEach(({ phrase, translationAnswer }) => {
                    csvContent += `${removeQuotes(phrase)};${removeQuotes(translationAnswer)}\n`;
                });
            }

            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", `${mode}_flashcards.csv`);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Updated export function: Export flashcards as JSONL with updated column name `translation_answer`
        function exportToJSON() {
            const currentCollection = mode === 'language' ? collectedLanguageFlashcards : collectedFlashcards;
            
            if (mode === 'language') {
                // Check and fill missing audio and IPA before export
                completeMissingAudio(currentCollection)
                    .then(completedCollection => {
                        // Once all audio is filled, proceed with export
                        downloadJSONL(completedCollection);
                    })
                    .catch(error => {
                        console.error('Error completing audio:', error);
                        // Fall back to exporting without completing audio
                        alert('Could not complete all audio. Exporting with available audio only.');
                        downloadJSONL(currentCollection);
                    });
            } else {
                // For regular flashcards, proceed with immediate export
                downloadJSONL(currentCollection);
            }
        }

        // Function to fetch and fill missing audio and IPA
        async function completeMissingAudio(collection) {
            const promises = [];
            const selectedLanguageButton = document.querySelector('#language-buttons .mode-btn.selected');
            const language = selectedLanguageButton ? selectedLanguageButton.dataset.language : 'English';
            
            // Create a copy of the collection that we'll modify
            const collectionCopy = JSON.parse(JSON.stringify(collection));
            // Track which flashcards were updated
            const updatedIndexes = [];
            
            for (let i = 0; i < collectionCopy.length; i++) {
                const flashcard = collectionCopy[i];
                let updated = false;
                
                // Check for missing IPA transcription
                if (!flashcard.ipa && flashcard.word) {
                    const ipaPromise = fetchIPA(flashcard.word, language)
                        .then(ipaData => {
                            flashcard.ipa = ipaData;
                            updated = true;
                        })
                        .catch(error => {
                            console.error(`Failed to get IPA for ${flashcard.word}:`, error);
                        });
                    promises.push(ipaPromise);
                }
                
                // If word audio is missing, create a promise to fetch it
                if (!flashcard.wordAudio && flashcard.word) {
                    const wordPromise = fetchAudio(flashcard.word, 'word', language)
                        .then(audioData => {
                            flashcard.wordAudio = audioData;
                            updated = true;
                            console.log(`Completed word audio for: ${flashcard.word}`);
                        });
                    promises.push(wordPromise);
                }
                
                // If phrase audio is missing, create a promise to fetch it
                if (!flashcard.phraseAudio && flashcard.phrase) {
                    const phrasePromise = fetchAudio(flashcard.phrase, 'phrase', language)
                        .then(audioData => {
                            flashcard.phraseAudio = audioData;
                            updated = true;
                            console.log(`Completed phrase audio for: ${flashcard.word}`);
                        });
                    promises.push(phrasePromise);
                }
                
                // If this flashcard will be updated, add its index to the list
                if (updated) {
                    updatedIndexes.push(i);
                }
            }
            
            // Wait for all audio fetch operations to complete
            if (promises.length > 0) {
                // Show a loading indicator
                const notification = document.createElement('div');
                notification.textContent = `Filling missing audio (${promises.length} items)...`;
                notification.style.position = 'fixed';
                notification.style.top = '20px';
                notification.style.right = '20px';
                notification.style.padding = '10px';
                notification.style.backgroundColor = 'rgba(0, 128, 0, 0.7)';
                notification.style.color = 'white';
                notification.style.borderRadius = '5px';
                notification.style.zIndex = '1000';
                document.body.appendChild(notification);
                
                try {
                    await Promise.all(promises);
                    
                    // Update the original collection with the filled audio data
                    updatedIndexes.forEach(index => {
                        collectedLanguageFlashcards[index] = collectionCopy[index];
                    });
                    
                    // Save the updated collection to localStorage
                    localStorage.setItem('collectedLanguageFlashcards', JSON.stringify(collectedLanguageFlashcards));
                    
                    notification.textContent = 'Audio completion finished!';
                    setTimeout(() => {
                        document.body.removeChild(notification);
                    }, 3000);
                } catch (error) {
                    notification.textContent = 'Error filling audio!';
                    notification.style.backgroundColor = 'rgba(255, 0, 0, 0.7)';
                    setTimeout(() => {
                        document.body.removeChild(notification);
                    }, 3000);
                    throw error;
                }
            } else {
                console.log('No missing audio to fill');
            }
            
            // Return the updated collection
            return collectionCopy;
        }

        // Add new function to fetch IPA data
        function fetchIPA(word, language) {
            return new Promise((resolve, reject) => {
                fetch('/get_ipa', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        word: word,
                        language: language
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.ipa || data.ipa === '') {
                        resolve(data.ipa);
                    } else {
                        reject(new Error(data.error || 'Failed to get IPA transcription'));
                    }
                })
                .catch(error => {
                    console.error('Error fetching IPA:', error);
                    reject(error);
                });
            });
        }

        // Function to fetch audio data
        function fetchAudio(text, type, language) {
            return new Promise((resolve, reject) => {
                fetch('/get_audio', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        word: text,
                        language: language,
                        type: type
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.audio) {
                        resolve(data.audio);
                    } else {
                        reject(new Error(data.error || 'Failed to get audio'));
                    }
                })
                .catch(error => {
                    console.error('Error fetching audio:', error);
                    reject(error);
                });
            });
        }

        // Function to download the JSONL file
        function downloadJSONL(collection) {
            let output = '';
            collection.forEach(item => {
                // Create a copy and update property name from translationAnswer to translation_answer if present
                const transformedItem = { ...item };
                if (transformedItem.translationAnswer !== undefined) {
                    transformedItem.translation_answer = transformedItem.translationAnswer;
                    delete transformedItem.translationAnswer;
                }
                output += JSON.stringify(transformedItem) + "\n";
            });
            
            const jsonContent = "data:text/json;charset=utf-8," + encodeURIComponent(output);
            const link = document.createElement("a");
            link.setAttribute("href", jsonContent);
            link.setAttribute("download", `${mode}_flashcards.jsonl`);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        document.getElementById('export-csv-option').addEventListener('click', function(e) {
            e.preventDefault();
            exportToCSV();
        });

        document.getElementById('export-json-option').addEventListener('click', function(e) {
            e.preventDefault();
            exportToJSON();
        });

        function clearCollection() {
            if (confirm('Are you sure you want to clear the entire collection? This action cannot be undone.')) {
                if (mode === 'language') {
                    collectedLanguageFlashcards = [];
                    languageCollectionCount = 0;
                    localStorage.removeItem('collectedLanguageFlashcards');
                    localStorage.removeItem('languageCollectionCount');
                } else {
                    collectedFlashcards = [];
                    flashcardCollectionCount = 0;
                    localStorage.removeItem('collectedFlashcards');
                    localStorage.removeItem('flashcardCollectionCount');
                }
                updateCollectionCount(0, mode);
                updateExportButtonVisibility();
            }
        }

        document.getElementById('clear-collection-option').addEventListener('click', function(e) {
            e.preventDefault();
            clearCollection();
        });

        // Initialize export button visibility
        updateExportButtonVisibility();

        function addRecentFile(filename) {
            let recentFiles = JSON.parse(localStorage.getItem('recentFiles')) || [];
            recentFiles = recentFiles.filter(file => file.filename !== filename);
            recentFiles.unshift({ filename: filename, date: new Date().toISOString() });
            recentFiles = recentFiles.slice(0, 5);  // Keep only the 5 most recent
            localStorage.setItem('recentFiles', JSON.stringify(recentFiles));
            loadRecentFiles();
        }

        function updateRecentPDFsList() {
            const recentPDFs = JSON.parse(localStorage.getItem('recentPDFs')) || [];
            recentPdfList.innerHTML = '';
            recentPDFs.forEach(pdf => {
                const li = document.createElement('li');
                li.textContent = `${pdf.filename} (${new Date(pdf.date).toLocaleDateString()})`;
                recentPdfList.appendChild(li);
            });
        }

        fileInput.addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (file.type !== 'application/pdf' && file.type !== 'text/plain' && file.type !== 'application/epub+zip') {
                console.error('Error: Not a PDF, TXT, or EPUB file');
                return;
            }
            loadFile(file);
            addRecentFile(file.name);
            this.nextElementSibling.textContent = file.name;
        });

        // Add a span next to the file input to display the selected file name
        const fileNameDisplay = document.createElement('span');
        fileNameDisplay.style.marginLeft = '10px';
        fileInput.parentNode.insertBefore(fileNameDisplay, fileInput.nextSibling);

        function handleGoToPage() {
            const pageInput = document.getElementById('page-input');
            const pageInputValue = pageInput.value.trim();
            
            // Return early if input is empty
            if (!pageInputValue) {
                alert('Please enter a page number');
                return;
            }
            
            const pageNumber = parseInt(pageInputValue);
            
            // Check if the input is a valid number
            if (isNaN(pageNumber)) {
                alert('Please enter a valid page number');
                return;
            }
            
            goToPage(pageNumber);
        }

        document.getElementById('go-to-page-btn').addEventListener('click', handleGoToPage);

        document.getElementById('page-input').addEventListener('keyup', function (event) {
            if (event.key === 'Enter') {
                handleGoToPage();
            }
        });

        function calculateZoomStep(currentScale) {
            return Math.max(0.1, Math.min(0.25, currentScale * 0.1));
        }

        document.getElementById('zoom-in-btn').addEventListener('click', function() {
            if (scale < maxScale) {
                const step = calculateZoomStep(scale);
                scale = Math.min(maxScale, scale + step);
                reRenderPDF();
                saveScaleForCurrentFile();
            }
        });

        document.getElementById('zoom-out-btn').addEventListener('click', function() {
            if (scale > minScale) {
                const step = calculateZoomStep(scale);
                scale = Math.max(minScale, scale - step);
                reRenderPDF();
                saveScaleForCurrentFile();
            }
        });

        function reRenderPDF() {
            pdfViewer.innerHTML = '';
            renderPage(pageNum);
        }

        function saveScaleForCurrentFile() {
            if (currentFileName) {
                localStorage.setItem(`scale_${currentFileName}`, scale);
            }
        }

        function loadScaleForCurrentFile() {
            if (currentFileName) {
                const savedScale = localStorage.getItem(`scale_${currentFileName}`);
                if (savedScale) {
                    scale = parseFloat(savedScale);
                }
            }
        }

        const modeButtons = document.querySelectorAll('.mode-btn');
        modeButtons.forEach(button => {
            button.addEventListener('click', function () {
                modeButtons.forEach(btn => btn.classList.remove('selected'));
                this.classList.add('selected');
                mode = this.dataset.mode;
                pdfViewer.style.cursor = mode === 'language' ? 'text' : 'default';
                document.getElementById('language-buttons').style.display = mode === 'language' ? 'flex' : 'none';
                systemPrompt.style.display = mode === 'flashcard' ? 'block' : 'none';
                document.getElementById('explain-prompt').style.display = mode === 'explain' ? 'block' : 'none';
                document.getElementById('language-prompt').style.display = mode === 'language' ? 'block' : 'none';
                submitBtn.style.display = 'block';
                
                // Update the collection button text and export button visibility
                updateAddToCollectionButtonText();
                updateExportButtonVisibility();
            });
        });

        const languageButtons = document.querySelectorAll('#language-buttons .mode-btn');
        languageButtons.forEach(button => {
            button.addEventListener('click', function (event) {
                event.preventDefault();
                languageButtons.forEach(btn => btn.classList.remove('selected'));
                this.classList.add('selected');
                const targetLanguage = this.dataset.language;
                saveLanguageChoice(targetLanguage);
                // Ensure the Language mode button remains selected
                document.querySelector('.mode-btn[data-mode="language"]').classList.add('selected');
                // Keep language buttons visible and Generate button visible
                submitBtn.style.display = 'block';
                // Set the mode to 'language'
                mode = 'language';
            });
        });

        let highlights = [];

        function attachLanguageModeListener(container) {
            container.addEventListener('mouseup', function (event) {
                if (event.altKey) {
                    const selection = window.getSelection();
                    if (selection.rangeCount > 0) {
                        const range = selection.getRangeAt(0);
                        const selectedText = selection.toString().trim();

                        console.log(selectedText);

                        if (selectedText !== '') {
                            console.log(range, container);
                            const highlight = createHighlight(range, container);
                            highlights.push(highlight);
                            saveHighlights();
                        }
                    }
                }
            });

            container.addEventListener('dblclick', function (event) {
                if (mode === 'language') {
                    const selection = window.getSelection();
                    const range = selection.getRangeAt(0);
                    const word = selection.toString().trim();

                    if (word !== '' && word.length < 20) {
                        // Highlight the selected word
                        const span = document.createElement('span');
                        span.style.backgroundColor = 'rgba(255, 255, 0, 0.5)';
                        span.textContent = word;
                        range.deleteContents();
                        range.insertNode(span);

                        const selectedLanguageButton = document.querySelector('#language-buttons .mode-btn.selected');
                        if (selectedLanguageButton) {
                            const targetLanguage = selectedLanguageButton.dataset.language;
                            const phrase = getPhrase(range, word);
                            generateLanguageFlashcard(word, phrase, targetLanguage);
                            speakWord(word);
                        } else {
                            console.error('No language selected');
                        }
                    }
                }
            });
        }

        function createHighlight(range, pageDiv) {
            const highlight = document.createElement('div');
            highlight.className = 'highlight';
            highlight.style.position = 'absolute';
            highlight.style.backgroundColor = 'rgba(255, 255, 0, 0.3)';
            highlight.style.pointerEvents = 'none';

            const rect = range.getBoundingClientRect();
            const pageBounds = pageDiv.getBoundingClientRect();

            highlight.style.left = (rect.left - pageBounds.left) + 'px';
            highlight.style.top = (rect.top - pageBounds.top) + 'px';
            highlight.style.width = rect.width + 'px';
            highlight.style.height = rect.height + 'px';

            pageDiv.appendChild(highlight);

            return {
                element: highlight,
                pageNumber: parseInt(pageDiv.dataset.pageNumber),
                rects: [{
                    left: rect.left - pageBounds.left,
                    top: rect.top - pageBounds.top,
                    width: rect.width,
                    height: rect.height
                }]
            };
        }

        function saveHighlights() {
            localStorage.setItem('pdfHighlights', JSON.stringify(highlights));
        }

        function loadHighlights() {
            const savedHighlights = JSON.parse(localStorage.getItem('pdfHighlights')) || [];
            highlights = savedHighlights;
            renderHighlights();
        }

        function renderHighlights() {
            highlights.forEach(highlight => {
                const pageDiv = document.querySelector(`.page[data-page-number="${highlight.pageNumber}"]`);
                if (pageDiv) {
                    const newHighlight = document.createElement('div');
                    newHighlight.className = 'highlight';
                    newHighlight.style.position = 'absolute';
                    newHighlight.style.backgroundColor = 'rgba(255, 255, 0, 0.3)';
                    newHighlight.style.pointerEvents = 'none';

                    const pageBounds = pageDiv.getBoundingClientRect();
                    const scale = parseFloat(pageDiv.style.width) / pageBounds.width;

                    highlight.rects.forEach(rect => {
                        const highlightRect = document.createElement('div');
                        highlightRect.style.position = 'absolute';
                        highlightRect.style.left = (rect.left * scale) + 'px';
                        highlightRect.style.top = (rect.top * scale) + 'px';
                        highlightRect.style.width = (rect.width * scale) + 'px';
                        highlightRect.style.height = (rect.height * scale) + 'px';
                        highlightRect.style.backgroundColor = 'inherit';
                        newHighlight.appendChild(highlightRect);
                    });

                    pageDiv.appendChild(newHighlight);
                }
            });
        }

        function getPhrase(range, word) {
            let startNode = range.startContainer;
            let endNode = range.endContainer;
            let startOffset = Math.max(0, range.startOffset - 50);
            let endOffset = Math.min(endNode.length, range.endOffset + 50);

            // Extract the phrase
            let phrase = '';
            let currentNode = startNode;
            while (currentNode) {
                if (currentNode.nodeType === Node.TEXT_NODE) {
                    const text = currentNode.textContent;
                    const start = currentNode === startNode ? startOffset : 0;
                    const end = currentNode === endNode ? endOffset : text.length;
                    phrase += text.slice(start, end);
                }
                if (currentNode === endNode) break;
                currentNode = currentNode.nextSibling;
            }

            // Ensure the word is bolded in the phrase
            const wordRegex = new RegExp(`\\b${word}\\b`, 'gi');
            phrase = phrase.replace(wordRegex, `<b>$&</b>`);

            return phrase.trim();
        }

        function saveLanguageChoice(language) {
            localStorage.setItem('selectedLanguage', language);
        }

        function loadLanguageChoice() {
            return localStorage.getItem('selectedLanguage') || 'English';
        }

        function setLanguageButton(language) {
            const languageButton = document.querySelector(`#language-buttons .mode-btn[data-language="${language}"]`);
            if (languageButton) {
                languageButtons.forEach(btn => btn.classList.remove('selected'));
                languageButton.classList.add('selected');
            }
        }

        submitBtn.addEventListener('click', function() {
            if (mode === 'language') {
                const selection = window.getSelection();
                if (selection.rangeCount > 0) {
                    const range = selection.getRangeAt(0);
                    const selectedText = selection.toString().trim();
                    
                    if (selectedText !== '') {
                        let selectedLanguageButton = document.querySelector('#language-buttons .mode-btn.selected');
                        if (!selectedLanguageButton) {
                            // Fallback: use the default language from localStorage
                            const defaultLanguage = loadLanguageChoice();
                            setLanguageButton(defaultLanguage);
                            selectedLanguageButton = document.querySelector('#language-buttons .mode-btn.selected');
                        }
                        if (selectedLanguageButton) {
                            const targetLanguage = selectedLanguageButton.dataset.language;
                            const phrase = getPhrase(range, selectedText);
                            generateLanguageFlashcard(selectedText, phrase, targetLanguage);
                            speakWord(selectedText);
                        }
                    } else {
                        alert('Please select some text first');
                    }
                } else {
                    alert('Please select some text first');
                }
            } else {
                generateContent();
            }
        });

        apiKeyInput.addEventListener('change', function () {
            apiKey = this.value;
            localStorage.setItem('lastWorkingAPIKey', apiKey);
        });

        // Load last working API key
        const lastWorkingAPIKey = localStorage.getItem('lastWorkingAPIKey');
        if (lastWorkingAPIKey) {
            apiKeyInput.value = lastWorkingAPIKey;
            apiKey = lastWorkingAPIKey;
        }

        // Infinite scrolling
        document.getElementById('left-panel').addEventListener('scroll', function () {
            if (this.scrollTop + this.clientHeight >= this.scrollHeight - 500) {
                if (pageNum < pdfDoc.numPages) {
                    pageNum++;
                    renderPage(pageNum);
                }
            }
        });

        function loadRecentFiles() {
            fetch('/get_recent_files')
                .then(response => response.json())
                .then(recentFiles => {
                    const fileList = document.getElementById('file-list');
                    fileList.innerHTML = '';
                    recentFiles.forEach(file => {
                        const li = document.createElement('li');
                        const a = document.createElement('a');
                        a.href = '#';
                        a.textContent = `${file.filename} (${new Date(file.date).toLocaleDateString()})`;
                        a.addEventListener('click', function (e) {
                            e.preventDefault();
                            fetch(`/open_pdf/${file.filename}`)
                                .then(response => response.blob())
                                .then(blob => {
                                    const fileType = file.filename.toLowerCase().endsWith('.pdf') ? 'application/pdf' : 'text/plain';
                                    const newFile = new File([blob], file.filename, { type: fileType });
                                    loadFile(newFile);
                                })
                                .catch(error => console.error('Error:', error));
                        });
                        li.appendChild(a);
                        fileList.appendChild(li);
                    });
                })
                .catch(error => console.error('Error loading recent files:', error));
        }

        // Call loadRecentFiles when the page loads
        window.addEventListener('load', loadRecentFiles);

        // Update recent files list after uploading a new file
        function uploadFile(file) {
            const formData = new FormData();
            formData.append('file', file);

            fetch('/upload_pdf', {
                method: 'POST',
                body: formData
            })
                .then(response => response.json())
                .then(data => {
                    if (data.message) {
                        console.log(data.message);
                        loadFile(file);
                        loadRecentFiles(); // Reload the recent files list
                    } else {
                        console.error(data.error);
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                });
        }

        // Update loadFile function to reload recent files list
        let book;
        let rendition;
        let currentScale = 100;

        function loadFile(file) {
            const pdfViewer = document.getElementById('pdf-viewer');
            const epubViewer = document.getElementById('epub-viewer');
            
            // Hide both viewers initially
            pdfViewer.style.display = 'none';
            epubViewer.style.display = 'none';

            if (file.name.endsWith('.pdf')) {
                pdfViewer.style.display = 'block';
                loadPDF(file);
            } else if (file.name.endsWith('.txt')) {
                pdfViewer.style.display = 'block'; // Assuming TXT files use the PDF viewer
                loadTXT(file);
            } else if (file.name.endsWith('.epub')) {
                epubViewer.style.display = 'block';
                loadEPUB(file);
            }
        }

        function loadEPUB(file) {
            console.log('loadEPUB function called with file:', file.name);

            const epubContainer = document.getElementById('epub-viewer');
            if (!epubContainer) {
                console.error('EPUB viewer container not found');
                return;
            }

            epubContainer.innerHTML = ''; // Clear previous content
            epubContainer.style.display = 'block';

            const reader = new FileReader();

            reader.onload = function(e) {
                console.log('FileReader onload event fired');
                const arrayBuffer = e.target.result;

                try {
                    book = ePub(arrayBuffer);
                    console.log('EPUB book object created:', book);

                    book.ready.then(() => {
                        console.log('EPUB book is ready');

                        rendition = book.renderTo('epub-viewer', {
                            width: '100%',
                            height: '100%',
                            spread: 'always',
                            sandbox: 'allow-scripts'
                        });

                        console.log('Rendition object created:', rendition);

                        rendition.display().then(() => {
                            console.log('EPUB content displayed');
                            setupNavigation();
                        }).catch(error => {
                            console.error('Error displaying EPUB content:', error);
                            epubContainer.innerHTML = 'Error displaying EPUB content. Please check console for details.';
                        });

                        if (document.getElementById('pdf-viewer')) {
                            document.getElementById('pdf-viewer').style.display = 'none';
                        }

                    }).catch(error => {
                        console.error('Error in book.ready:', error);
                        epubContainer.innerHTML = 'Error preparing EPUB. Please check console for details.';
                    });
                } catch (error) {
                    console.error('Error creating EPUB book object:', error);
                    epubContainer.innerHTML = 'Error loading EPUB. Please check console for details.';
                }
            };

            reader.onerror = function(e) {
                console.error('Error reading file:', e);
                epubContainer.innerHTML = 'Error reading file. Please try again.';
            };

            reader.readAsArrayBuffer(file);
        }

        function setupNavigation() {
            const prevBtn = document.getElementById('prev-btn');
            const nextBtn = document.getElementById('next-btn');
            const zoomInBtn = document.getElementById('zoom-in-btn');
            const zoomOutBtn = document.getElementById('zoom-out-btn');

            if (prevBtn) prevBtn.onclick = prevPage;
            if (nextBtn) nextBtn.onclick = nextPage;
            if (zoomInBtn) zoomInBtn.onclick = zoomIn;
            if (zoomOutBtn) zoomOutBtn.onclick = zoomOut;

            // Enable keyboard navigation
            document.addEventListener('keydown', handleKeyPress);
        }

        function prevPage() {
            if (rendition) rendition.prev();
        }

        function nextPage() {
            if (rendition) rendition.next();
        }

        function zoomIn() {
            if (rendition) {
                currentScale += 10;
                setZoom();
            }
        }

        function zoomOut() {
            if (rendition) {
                currentScale -= 10;
                if (currentScale < 50) currentScale = 50; // Prevent zooming out too much
                setZoom();
            }
        }

        function setZoom() {
            if (rendition) {
                rendition.themes.fontSize(`${currentScale}%`);
            }
        }

        function handleKeyPress(e) {
            switch(e.key) {
                case "ArrowLeft":
                    prevPage();
                    break;
                case "ArrowRight":
                    nextPage();
                    break;
            }
        }

        // Save current page before unloading
        window.addEventListener('beforeunload', function () {
            if (currentFileName) {
                localStorage.setItem(`lastPage_${currentFileName}`, pageNum);
            }
        });

        // Initialize recent PDFs list
        window.onload = function () {
            loadRecentFiles();

            // Add event listener for settings icon
            document.getElementById('settings-icon').addEventListener('click', function () {
                const settingsPanel = document.getElementById('settings-panel');
                settingsPanel.style.display = settingsPanel.style.display === 'none' ? 'block' : 'none';
            });

            // Remove 'selected' class from main mode buttons only
            document.getElementById('mode-toggle').querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('selected'));

            // Set default mode to language
            mode = 'language';
            document.querySelector('.mode-btn[data-mode="language"]').classList.add('selected');
            document.getElementById('language-buttons').style.display = 'flex';
            document.getElementById('submit-btn').style.display = 'block';
            systemPrompt.style.display = 'none';
            document.getElementById('explain-prompt').style.display = 'none';
            document.getElementById('language-prompt').style.display = 'block';

            // Set default language to English if not already set
            if (!localStorage.getItem('selectedLanguage')) {
                saveLanguageChoice('English');
            }

            // Load and set the saved language choice
            const savedLanguage = loadLanguageChoice();
            setLanguageButton(savedLanguage);
            
            // Make sure export buttons and collection count are properly initialized
            updateExportButtonVisibility();
            updateAddToCollectionButtonText();
        };

        fileInput.addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (file.type !== 'application/pdf' && file.type !== 'text/plain' && file.type !== 'application/epub+zip') {
                console.error('Error: Not a PDF, TXT, or EPUB file');
                return;
            }
            uploadFile(file);
        });

        function uploadFile(file) {
            const formData = new FormData();
            formData.append('file', file);

            fetch('/upload_file', {
                method: 'POST',
                body: formData
            })
                .then(response => response.json())
                .then(data => {
                    if (data.message) {
                        console.log(data.message);
                        loadFile(file);
                        loadRecentFiles();
                        addRecentFile(file.name);
                    } else {
                        console.error(data.error);
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                });
        }

        document.addEventListener("DOMContentLoaded", () => {
            // Ensure the variables are defined from /static/js/prompts.js
            if (typeof FLASHCARD_PROMPT !== 'undefined') {
                document.getElementById('system-prompt').value = FLASHCARD_PROMPT;
            }
            if (typeof EXPLAIN_PROMPT !== 'undefined') {
                document.getElementById('explain-prompt').value = EXPLAIN_PROMPT;
            }
            if (typeof LANGUAGE_PROMPT !== 'undefined') {
                document.getElementById('language-prompt').value = LANGUAGE_PROMPT;
            }

            // Populate the model select options
            const modelSelect = document.getElementById('model-select');
            availableModels.forEach(model => {
                const option = document.createElement('option');
                option.value = model;
                option.textContent = model;
                modelSelect.appendChild(option);
            });

            // Set default model to the first one in the list instead of hard-coding Gemini
            const firstModel = availableModels[0]; // New: use the first model from availableModels
            modelSelect.value = firstModel;          // Update the select element
            selectedModel = firstModel;              // Update the global selectedModel value

            // Update API key placeholder based on selected model on change
            modelSelect.addEventListener('change', function() {
                selectedModel = this.value;
                const requiredKey = MODEL_API_KEY_MAPPING[selectedModel];
                apiKeyInput.placeholder = `Enter ${requiredKey}`;
            });

            // Set initial API key placeholder based on the first model
            const initialKey = MODEL_API_KEY_MAPPING[firstModel]; // Updated to use firstModel
            apiKeyInput.placeholder = `Enter ${initialKey}`;
        });

        // Ensure these run after the DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Dropdown toggle logic for the collection dropdown
            var collectionDropbtn = document.getElementById('collection-dropbtn');
            var dropdownContent = document.getElementById('collection-dropdown-content');
            
            collectionDropbtn.addEventListener('click', function(e) {
                e.stopPropagation();
                dropdownContent.classList.toggle('show');
                collectionDropbtn.classList.toggle('active');
            });
            
            document.addEventListener('click', function(e) {
                if (!dropdownContent.contains(e.target)) {
                    dropdownContent.classList.remove('show');
                    collectionDropbtn.classList.remove('active');
                }
            });
            
            // Update event listeners for dropdown options instead of separate buttons
            document.getElementById('add-to-collection-option').addEventListener('click', function(e) {
                e.preventDefault();
                addToCollection();
            });
            document.getElementById('clear-collection-option').addEventListener('click', function(e) {
                e.preventDefault();
                clearCollection();
            });
        })

        // Dark mode toggle functionality
        const darkModeToggle = document.getElementById('dark-mode-toggle');
        let isDarkMode = localStorage.getItem('darkMode') === 'true';

        // Initialize dark mode state
        if (isDarkMode) {
            document.body.classList.add('dark-mode');
            darkModeToggle.textContent = '‚òÄÔ∏è';
        }

        darkModeToggle.addEventListener('click', () => {
            isDarkMode = !isDarkMode;
            document.body.classList.toggle('dark-mode');
            darkModeToggle.textContent = isDarkMode ? '‚òÄÔ∏è' : 'üåô';
            localStorage.setItem('darkMode', isDarkMode);
        });
    </script>
</body>

</html>
